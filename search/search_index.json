{
    "docs": [
        {
            "location": "/", 
            "text": "referee\n\n\nA collection of assertions to be used with a unit testing framework. \nreferee\n works well with any CommonJS compliant testing framework out of the box, and can easily be configured to work with most any testing framework. See also expectations if you like the alternative API\n(\nexpect(thing).toBe*\n).\n\n\nreferee\n contains lots of assertions. We strongly believe that high-level assertions are essential in the interest of producing clear and intent-revealing tests, and they also give you to-the-point failure messages.\n\n\nAssertions and refutations\n\n\nUnlike most assertion libraries, \nreferee\n does not have \nassert.notXyz\n assertions to refute some fact. Instead, it has \nrefutations\n, heavily inspired by Ruby's \nminitest\n:\n\n\nvar assert = referee.assert;\nvar refute = referee.refute;\n\nassert.equals(42, 42);\nrefute.equals(42, 43);\n\n\n\n\nRefutations help express \"assert not ...\" style verification in a much clearer way. It also brings with it a nice consistency in that any \nassert.xyz\n always has a corresponding \nrefute.xyz\n that does the opposite check.\n\n\nassert()\n\n\nassert(actual[, message]);\n\n\n\n\nFails if \nactual\n is falsy (\n0\n, \n\"\"\n, \nnull\n, \nundefined\n, \nNaN\n). Fails with either the provided message or \"Expected null to be truthy\". This behavior differs from all other assertions, which prepend the optional message argument.\n\n\nassert({ not: \nFalsy\n }, \nThis will pass\n);\nassert(null, \nThis will fail\n); // Fails with custom message\nassert(null); // Fails\nassert(34);   // Passes\n\n\n\n\nrefute()\n\n\nrefute(actual[, message])\n\n\n\n\nFails if actual is truthy. Fails with either the provided message or \"Expected null to be falsy\". This behavior differs from all other refutations, which prepend the optional message argument.\n\n\nrefute({ not: \nFalsy\n }, \nThis will fail\n); // Fails with custom message\nrefute(null, \nThis will pass\n);\nrefute(null); // Passes\nrefute(34);   // Fails\n\n\n\n\nPredefined Assertions\n\n\nThe following assertions can be used with \nassert\n and \nrefute\n. They\nare described for \nassert\n, but the corresponding failure messages for\n\nrefute\n are also mentioned. For \nrefute\n the behaviour is exactly\nopposed.\n\n\nAll assertions support an optional \nmessage\n argument, which is\nprepended to the failure message.\n\n\nOverview:\n\n\n\n\nsame()\n\n\nequals()\n\n\ngreater()\n\n\nless()\n\n\ndefined()\n\n\nisNull()\n\n\nmatch()\n\n\nexception()\n\n\nnear()\n\n\nhasPrototype()\n\n\ncontains()\n\n\ntagName()\n\n\nclassName()\n\n\njson()\n\n\n\n\nmatchJson()\n\n\n\n\n\n\nisArray()\n\n\n\n\nisArrayBuffer()\n\n\nisArrayLike()\n\n\nisBoolean()\n\n\nisDataView()\n\n\nisDate()\n\n\nisError()\n\n\nisEvalError()\n\n\nisFalse()\n\n\nisFloat32Array()\n\n\nisFloat64Array()\n\n\nisFunction()\n\n\nisInfinity()\n\n\nisIntlCollator()\n\n\nisIntlDateTimeFormat()\n\n\nisIntlNumberFormat()\n\n\nisMap()\n\n\nisNaN()\n\n\nisNull()\n\n\nisNumber()\n\n\nisObject()\n\n\nisPromise()\n\n\nisRangeError()\n\n\nisReferenceError()\n\n\nisRegExp()\n\n\nisSet()\n\n\nisString()\n\n\nisSymbol()\n\n\nisSyntaxError()\n\n\nisTrue()\n\n\nisTypeError()\n\n\nisUint16Array()\n\n\nisUint32Array()\n\n\nisUint8Array()\n\n\nisUint8Array()\n\n\nisUint8clampedArray()\n\n\nisURIError()\n\n\nisWeakMap()\n\n\nisWeakSet()\n\n\n\n\nsame()\n\n\nassert.same(actual, expected[, message])\n\n\n\n\nFails if \nactual\n is not the same object (\n===\n) as \nexpected\n. To compare similar objects, such as { name: \"Chris\", id: 42 } and { id: 42, name: \"Chris\" } (not the same instance), see \nequals()\n.\n\n\nvar obj = { id: 42, name: \nChris\n };\nassert.same(obj, obj);                       // Passes\nassert.same(obj, { id: 42, name: \nChris\n }); // Fails\n\n\n\n\nMessages\n\n\nassert.same.message = \n${actual} expected to be the same object as ${expected}\n;\nrefute.same.message = \n${actual} expected not to be the same object as ${expected}\n;\n\n\n\n\nequals()\n\n\nassert.equals(actual, expected[, message])\n\n\n\n\nCompares \nactual\n to \nexpected\n property by property. If the property count does not match, or if any of \nactual\n\u2018s properties do not match the corresponding property in \nexpected\n, the assertion fails. Object properties are verified recursively.\n\n\nIf \nactual\n is \nnull\n or \nundefined\n, an exact match is required. Date objects are compared by their \ngetTime\n method. Regular expressions are compared by their string representations. Primitives are compared using \n==\n, i.e., with coercion.\n\n\nequals\n passes when comparing an arguments object to an array if the both contain the same elements.\n\n\nassert.equals({ name: \nProfessor Chaos\n }, { name: \nProfessor Chaos\n }); // Passes\nassert.equals({ name: \nProfessor Chaos\n }, { name: \nDr Evil\n }); // Fails\n\n\n\n\nMessages\n\n\nassert.equals.message = \n${actual} expected to be equal to ${expected}\n;\nrefute.equals.message = \n${actual} expected not to be equal to ${expected}\n;\n\n\n\n\ngreater()\n\n\nassert.greater(actual, expected[, message])\n\n\n\n\nFails if \nactual\n is equal to or less than \nexpected\n.\n\n\nassert.greater(2, 1); // Passes\nassert.greater(1, 1); // Fails\nassert.greater(1, 2); // Fails\n\n\n\n\nMessages\n\n\nassert.greater.message = \nExpected ${actual} to be greater than ${expected}\n;\nrefute.greater.message = \nExpected ${actual} to be less than or equal to ${expected}\n;\n\n\n\n\nless()\n\n\nassert.less(actual, expected[, message])\n\n\n\n\nFails if \nactual\n is equal to or greater than \nexpected\n.\n\n\nassert.less(1, 2); // Passes\nassert.less(1, 1); // Fails\nassert.less(2, 1); // Fails\n\n\n\n\nMessages\n\n\nassert.less.message = \nExpected ${actual} to be less than ${expected}\n;\nrefute.less.message = \nExpected ${actual} to be greater than or equal to ${expected}\n;\n\n\n\n\ndefined()\n\n\nassert.defined(object[, message])\n\n\n\n\nFails if \nobject\n is undefined.\n\n\nvar a;\nassert.defined({});  // Passes\nassert.defined(a); // Fails\n\n\n\n\nMessages\n\n\nassert.defined.message = \nExpected to be defined\n;\nrefute.defined.message = \nExpected ${actual} (${actualType}) not to be defined\n;\n\n\n\n\nisNull()\n\n\nassert.isNull(object[, message])\n\n\n\n\nFails if \nobject\n is not \nnull\n.\n\n\nassert.isNull(null, \nThis will pass\n);\nassert.isNull({}, \nThis will fail\n);\nassert.isNull(null); // Passes\nassert.isNull({});   // Fails\n\n\n\n\nMessages\n\n\nassert.isNull.message = \nExpected ${actual} to be null\n;\nrefute.isNull.message = \nExpected not to be null\n;\n\n\n\n\nmatch()\n\n\nassert.match(actual, matcher[, message])\n\n\n\n\nFails if \nmatcher\n is not a partial match for \nactual\n. Accepts a wide range of input combinations. Note that \nassert.match\n is not symmetric - in some cases \nassert.match(a, b)\n may pass while \nassert.match(b, a)\n fails.\n\n\nString matcher\n\n\nIn its simplest form, \nassert.match\n performs a case insensitive substring match. When the matcher is a string, the \nactual\n object is converted to a string, and the assertion passes if \nactual\n is a case-insensitive substring of expected as a string.\n\n\nassert.match(\nGive me something\n, \nGive\n);                           // Passes\nassert.match(\nGive me something\n, \nsumptn\n);                         // Fails\nassert.match({ toString: function () { return \nyeah\n; } }, \nYeah!\n); // Passes\n\n\n\n\nThe last example is not symmetric. When the matcher is a string, the actual value is coerced to a string - in this case using \ntoString\n. Changing the order of the arguments would cause the matcher to be an object, in which case different rules apply (see below).\n\n\nBoolean matcher\n\n\nPerforms a strict (i.e. \n===\n) match with the object. So, only \ntrue\n matches \ntrue\n, and only \nfalse\n matches \nfalse\n.\n\n\nRegular expression matcher\n\n\nWhen the matcher is a regular expression, the assertion will pass if \nexpected.test(actual)\n is \ntrue\n. \nassert.match\n is written in a generic way, so any object with a \ntest\n method will be used as a matcher this way.\n\n\nassert.match(\nGive me something\n, /^[a-z\\s]$/i); // Passes\nassert.match(\nGive me something\n, /[0-9]/); // Fails\nassert.match({ toString: function () { return \nyeah!\n; } }, /yeah/); // Passes\nassert.match(234, /[a-z]/); // Fails\n\n\n\n\nNumber matcher\n\n\nWhen the matcher is a number, the assertion will pass if \nmatcher == actual\n.\n\n\nassert.match(\n123\n, 123); // Passes\nassert.match(\nGive me something\n, 425); // Fails\nassert.match({ toString: function () { return \n42\n; } }, 42); // Passes\nassert.match(234, 1234); // Fails\n\n\n\n\nFunction matcher\n\n\nWhen the matcher is a function, it is called with \nactual\n as its only argument. The assertion will pass if the function returns \ntrue\n. A strict match is performed against the return value, so a boolean \ntrue\n is required, truthy is not enough.\n\n\n// Passes\nassert.match(\n123\n, function (exp) {\n    return exp == \n123\n;\n});\n\n// Fails\nassert.match(\nGive me something\n, function () {\n    return \nok\n;\n});\n\n// Passes\nassert.match({\n    toString: function () {\n        return \n42\n;\n    }\n}, function () { return true; });\n\n// Fails\nassert.match(234, function () {});\n\n\n\n\nObject matcher\n\n\nAs mentioned above, if an object matcher defines a test method the assertion will pass if \nmatcher.test(actual)\n returns truthy. If the object does not have a \ntest\n method, a recursive match is performed. If all properties of \nmatcher\n matches corresponding properties in \nactual\n, the assertion passes. Note that the object matcher does not care if the number of properties in the two objects are the same - only if all properties in the matcher recursively \u201cmatches\u201d ones in the actual object.\n\n\n// Passes\nassert.match(\n123\n, {\n    test: function (arg) {\n        return arg == 123;\n    }\n});\n\n// Fails\nassert.match({}, { prop: 42 });\n\n// Passes\nassert.match({\n    name: \nChris\n,\n    profession: \nProgrammer\n\n}, {\n    name: \nChris\n\n});\n\n// Fails\nassert.match(234, {\n    name: \nChris\n\n});\n\n\n\n\nDOM elements\n\n\nassert.match\n can be very helpful when asserting on DOM elements, because it allows you to compare several properties with one assertion:\n\n\nvar el = document.getElementById(\nmyEl\n);\n\nassert.match(el, {\n    tagName: \nh2\n,\n    className: \nitem\n,\n    innerHTML: \nHowdy\n\n});\n\n\n\n\nMessages\n\n\nassert.match.exceptionMessage = \n${exceptionMessage}\n;\nrefute.match.exceptionMessage = \n${exceptionMessage}\n;\n\n\n\n\nUsed when the matcher function throws an exception. This happens if the matcher is not any of the accepted types, for instance, a boolean.\n\n\nassert.match.message = \n${actual} expected to match ${expected}\n;\nrefute.match.message = \n${actual} expected not to match ${expected}\n;\n\n\n\n\nisObject()\n\n\nassert.isObject(object[, message])\n\n\n\n\nFails if \nobject\n is not an object or if it is \nnull\n.\n\n\nassert.isObject({});             // Passes\nassert.isObject(42);             // Fails\nassert.isObject([1, 2, 3]);      // Passes\nassert.isObject(function () {}); // Fails\n\n\n\n\nMessages\n\n\nassert.isObject.message = \n${actual} (${actualType}) expected to be object and not null\n;\nrefute.isObject.message = \n${actual} expected to be null or not an object\n;\n\n\n\n\nisFunction()\n\n\nassert.isFunction(actual[, message])\n\n\n\n\nFails if \nactual\n is not a function.\n\n\nassert.isFunction({});             // Fails\nassert.isFunction(42);             // Fails\nassert.isFunction(function () {}); // Passes\n\n\n\n\nMessages\n\n\nassert.isFunction.message = \n${actual} (${actualType}) expected to be function\n;\nrefute.isFunction.message = \n${actual} expected not to be function\n;\n\n\n\n\nisTrue()\n\n\nassert.isTrue(actual[, message])\n\n\n\n\nFails if \nactual\n is not \ntrue\n.\n\n\nassert.isTrue(\n2\n == 2);  // Passes\nassert.isTrue(\n2\n === 2); // Fails\n\n\n\n\nMessages\n\n\nassert.isTrue.message = \nExpected ${actual} to be true\n;\nrefute.isTrue.message = \nExpected ${actual} to not be true\n;\n\n\n\n\nisFalse()\n\n\nassert.isFalse(actual[, message])\n\n\n\n\nFails if \nactual\n is not \nfalse\n.\n\n\nassert.isFalse(\n2\n === 2); // Passes\nassert.isFalse(\n2\n == 2);  // Fails\n\n\n\n\nMessages\n\n\nassert.isFalse.message = \nExpected ${actual} to be false\n;\nrefute.isFalse.message = \nExpected ${actual} to not be false\n;\n\n\n\n\nisString()\n\n\nassert.isString(actual[, message])\n\n\n\n\nFails if the type of actual is not \"string\".\n\n\nassert.isString(\n2\n); // Passes\nassert.isString(2);   // Fails\n\n\n\n\nMessages\n\n\nassert.isString.message = \nExpected ${actual} (${actualType}) to be string\n;\nrefute.isString.message = \nExpected ${actual} not to be string\n;\n\n\n\n\nisBoolean()\n\n\nassert.isBoolean(actual[, message])\n\n\n\n\nFails if the type of \nactual\n is not \"boolean\".\n\n\nassert.isBoolean(true);   // Passes\nassert.isBoolean(2 \n 2);  // Passes\nassert.isBoolean(\ntrue\n); // Fails\n\n\n\n\nMessages\n\n\nassert.isBoolean.message = \nExpected ${actual} (${actualType}) to be boolean\n;\nrefute.isBoolean.message = \nExpected ${actual} not to be boolean\n;\n\n\n\n\nisNumber()\n\n\nassert.isNumber(actual[, message])\n\n\n\n\nFails if the type of \nactual\n is not \"number\" or is \nNaN\n.\n\n\nassert.isNumber(12);   // Passes\nassert.isNumber(\n12\n); // Fails\nassert.isNumber(NaN);  // Fails\n\n\n\n\nMessages\n\n\nassert.isNumber.message = \nExpected ${actual} (${actualType}) to be a non-NaN number\n;\nrefute.isNumber.message = \nExpected ${actual} to be NaN or a non-number value\n;\n\n\n\n\nisNaN()\n\n\nassert.isNaN(actual[, message])\n\n\n\n\nFails if \nactual\n is not \nNaN\n. Does not perform coercion in contrast to the standard javascript function \nisNaN\n.\n\n\nassert.isNaN(NaN);           // Passes\nassert.isNaN(\nabc\n / \ndef\n); // Passes\nassert.isNaN(12);            // Fails\nassert.isNaN({});            // Fails, would pass for standard javascript function isNaN\n\n\n\n\nMessages\n\n\nassert.isNaN.message = \nExpected ${actual} to be NaN\n;\nrefute.isNaN.message = \nExpected not to be NaN\n;\n\n\n\n\nisArray()\n\n\nassert.isArray(actual[, message])\n\n\n\n\nFails if the object type of \nactual\n is not \nArray\n.\n\n\nassert.isArray([1, 2, 3]); // Passes\nassert.isArray({});        // Fails\n\n\n\n\nMessages\n\n\nassert.isArray.message = \nExpected ${actual} to be array\n;\nrefute.isArray.message = \nExpected ${actual} not to be array\n;\n\n\n\n\nisArrayBuffer()\n\n\nassert.isArrayBuffer(actual[, message])\n\n\n\n\nFails if the object type of \nactual\n is not \nArrayBuffer\n.\n\n\nassert.isArrayBuffer(new ArrayBuffer(8)); // Passes\nassert.isArrayBuffer({});                 // Fails\n\n\n\n\nMessages\n\n\nassert.isArrayBuffer.message = \nExpected ${actual} to be an ArrayBuffer\n;\nrefute.isArrayBuffer.message = \nExpected ${actual} not to be an ArrayBuffer\n;\n\n\n\n\nisArrayLike()\n\n\nassert.isArrayLike(actual[, message])\n\n\n\n\nFails if none of the following conditions are fulfilled:\n\n\n\n\nthe object type of \nactual\n is \nArray\n\n\nactual\n is an \narguments\n object\n\n\nactual\n is an object providing a property \nlength\n of type \"number\" and a \nproperty\n splice of type \"function\"\n\n\n\n\nassert.isArrayLike([1, 2, 3]);                            // Passes\nassert.isArrayLike(arguments);                            // Passes\nassert.isArrayLike({ length: 0, splice: function() {} }); // Passes\nassert.isArrayLike({});                                   // Fails\n\n\n\n\nMessages\n\n\nassert.isArrayLike.message = \nExpected ${actual} to be array like\n;\nrefute.isArrayLike.message = \nExpected ${actual} not to be array like\n;\n\n\n\n\nisDataView()\n\n\nassert.isDataView(actual[, message])\n\n\n\n\nFails if the object type of \nactual\n is not \nDataView\n.\n\n\nassert.isDataView(new DataView(new ArrayBuffer(16)); // Passes\nassert.isDataView({});                               // Fails\n\n\n\n\nMessages\n\n\nassert.isDataView.message = \nExpected ${actual} to be a DataView\n;\nrefute.isDataView.message = \nExpected ${actual} not to be a DataView\n;\n\n\n\n\nisDate()\n\n\nassert.isDate(actual[, message])\n\n\n\n\nFails if \nactual\n is not an instance of \nDate\n.\n\n\nassert.isDate(new Date());  // Passes\nassert.isDate(12345678);    // Fails\nassert.isDate(\napple pie\n); // Fails\n\n\n\n\nMessages\n\n\nassert.isDate.message = \nExpected ${actual} to be a Date\n;\nrefute.isDate.message = \nExpected ${actual} not to be a Date\n;\n\n\n\n\nisError()\n\n\nassert.isError(actual[, message])\n\n\n\n\nFails if \nactual\n is not an instance of \nError\n.\nPasses for all \nbuilt in error types\n and errors derived from a built in error type.\n\n\nassert.isError(new Error(\nthis is an error\n); // Passes\nassert.isError(\nthis is not an error\n);       // Fails\n\n\n\n\nMessages\n\n\nassert.isError.message = \nExpected ${actual} to be an Error\n;\nrefute.isError.message = \nExpected ${actual} not to be an Error\n;\n\n\n\n\nisEvalError()\n\n\nassert.isEvalError(actual[, message])\n\n\n\n\nFails if \nactual\n is not an instance of \nEvalError\n.\n\n\nassert.isEvalError(new EvalError(\nthis is an eval error\n));  // Passes\nassert.isEvalError(new Error(\nthis is not an eval error\n)); // Fails\n\n\n\n\nMessages\n\n\nassert.isEvalError.message = \nExpected ${actual} to be an EvalError\n;\nrefute.isEvalError.message = \nExpected ${actual} not to be an EvalError\n;\n\n\n\n\nisFloat32Array()\n\n\nassert.isFloat32Array(actual[, message])\n\n\n\n\nFails if \nactual\n is not an instance of \nFloat32Array\n.\n\n\nassert.isFloat32Array(new Float32Array(2)); // Passes\nassert.isFloat32Array(new Float64Array(2)); // Fails\n\n\n\n\nMessages\n\n\nassert.isFloat32Array.message = \nExpected ${actual} to be a Float32Array\n;\nrefute.isFloat32Array.message = \nExpected ${actual} not to be n Float32Array\n;\n\n\n\n\nisFloat64Array()\n\n\nassert.isFloat64Array(actual[, message])\n\n\n\n\nFails if \nactual\n is not an instance of \nFloat64Array\n.\n\n\nassert.isFloat64Array(new Float64Array(2)); // Passes\nassert.isFloat64Array(new Float32Array(2)); // Fails\n\n\n\n\nMessages\n\n\nassert.isFloat64Array.message = \nExpected ${actual} to be a Float64Array\n;\nrefute.isFloat64Array.message = \nExpected ${actual} not to be a Float64Array\n;\n\n\n\n\nisInfinity()\n\n\nassert.isInfinity(actual[, message])\n\n\n\n\nFails if \nactual\n is not \nInfinity\n.\n\n\nassert.isInfinity(Infinity); // Passes\nassert.isInfinity(42);       // Fails\n\n\n\n\nMessages\n\n\nassert.isInfinity.message = \nExpected ${actual} to be Infinity\n;\nrefute.isInfinity.message = \nExpected ${actual} not to be Infinity\n;\n\n\n\n\nisInt8Array()\n\n\nassert.isInt8Array(actual[, message])\n\n\n\n\nFails if \nactual\n is not an instance of \nInt8Array\n.\n\n\nassert.isInt8Array(new Int8Array(2)); // Passes\nassert.isInt8Array(new Int16Array(2)); // Fails\n\n\n\n\nMessages\n\n\nassert.isInt8Array.message = \nExpected ${actual} to be an Int8Array\n;\nrefute.isInt8Array.message = \nExpected ${actual} not to be an Int8Array\n;\n\n\n\n\nisInt16Array()\n\n\nassert.isInt16Array(actual[, message])\n\n\n\n\nFails if \nactual\n is not an instance of \nInt16Array\n.\n\n\nassert.isInt16Array(new Int16Array(2)); // Passes\nassert.isInt16Array(new Int32Array(2)); // Fails\n\n\n\n\nMessages\n\n\nassert.isInt16Array.message = \nExpected ${actual} to be an Int16Array\n;\nrefute.isInt16Array.message = \nExpected ${actual} not to be an Int16Array\n;\n\n\n\n\nisInt32Array()\n\n\nassert.isInt32Array(actual[, message])\n\n\n\n\nFails if \nactual\n is not an instance of \nInt32Array\n.\n\n\nassert.isInt32Array(new Int32Array(2)); // Passes\nassert.isInt32Array(new Int16Array(2)); // Fails\n\n\n\n\nMessages\n\n\nassert.isInt32Array.message = \nExpected ${actual} to be an Int32Array\n;\nrefute.isInt32Array.message = \nExpected ${actual} not to be an Int32Array\n;\n\n\n\n\nisIntlCollator()\n\n\nassert.isIntlCollator(actual[, message])\n\n\n\n\nFails if \nactual\n is not an instance of \nIntl.Collator\n.\n\n\nassert.isIntlCollator(new Intl.Collator()); // Passes\nassert.isIntlCollator({});                   // Fails\n\n\n\n\nMessages\n\n\nassert.isIntlCollator.message = \nExpected ${actual} to be an Intl.Collator\n;\nrefute.isIntlCollator.message = \nExpected ${actual} not to be an Intl.Collator\n;\n\n\n\n\nisIntlDateTimeFormat()\n\n\nassert.isIntlDateTimeFormat(actual[, message])\n\n\n\n\nFails if \nactual\n is not an instance of \nIntl.DateTimeFormat\n.\n\n\nassert.isIntlDateTimeFormat(new Intl.DateTimeFormat()); // Passes\nassert.isIntlDateTimeFormat({});                        // Fails\n\n\n\n\nMessages\n\n\nassert.isIntlDateTimeFormat.message = \nExpected ${actual} to be an Intl.DateTimeFormat\n;\nrefute.isIntlDateTimeFormat.message = \nExpected ${actual} not to be an Intl.DateTimeFormat\n;\n\n\n\n\nisIntlNumberFormat()\n\n\nassert.isIntlNumberFormat(actual[, message])\n\n\n\n\nFails if \nactual\n is not an instance of \nIntl.NumberFormat\n.\n\n\nassert.isIntlNumberFormat(new Intl.NumberFormat()); // Passes\nassert.isIntlNumberFormat({});                      // Fails\n\n\n\n\nMessages\n\n\nassert.isIntlNumberFormat.message = \nExpected ${actual} to be an Intl.NumberFormat\n;\nrefute.isIntlNumberFormat.message = \nExpected ${actual} not to be an Intl.NumberFormat\n;\n\n\n\n\nisMap()\n\n\nassert.Map(actual[, message])\n\n\n\n\nFails if \nactual\n is not an instance of \nMap\n.\n\n\nassert.isMap(new Map()); // Passes\nassert.isMap({});        // Fails\n\n\n\n\nMessages\n\n\nassert.isMap.message = \nExpected ${actual} to be a Map\n;\nrefute.isMap.message = \nExpected ${actual} not to be a Map\n;\n\n\n\n\nisPromise()\n\n\nassert.Promise(actual[, message])\n\n\n\n\nFails if \nactual\n is not an instance of \nPromise\n.\n\n\nassert.isPromise(new Promise()); // Passes\nassert.isPromise({});            // Fails\n\n\n\n\nMessages\n\n\nassert.isPromise.message = \nExpected ${actual} to be a Promise\n;\nrefute.isPromise.message = \nExpected ${actual} not to be a Promise\n;\n\n\n\n\nisRangeError()\n\n\nassert.isRangeError(actual[, message])\n\n\n\n\nFails if \nactual\n is not an instance of \nRangeError\n.\n\n\nassert.isRangeError(new RangeError(\nthis is a range error\n));  // Passes\nassert.isRangeError(new Error(\nthis is not a range error\n));   // Fails\n\n\n\n\nMessages\n\n\nassert.isRangeError.message = \nExpected ${actual} to be an RangeError\n;\nrefute.isRangeError.message = \nExpected ${actual} not to be an RangeError\n;\n\n\n\n\nisReferenceError()\n\n\nassert.isReferenceError(actual[, message])\n\n\n\n\nFails if \nactual\n is not an instance of \nReferenceError\n.\n\n\nassert.isReferenceError(new ReferenceError(\nthis is a range error\n));  // Passes\nassert.isReferenceError(new Error(\nthis is not a range error\n));   // Fails\n\n\n\n\nMessages\n\n\nassert.isReferenceError.message = \nExpected ${actual} to be a ReferenceError\n;\nrefute.isReferenceError.message = \nExpected ${actual} not to be a ReferenceError\n;\n\n\n\n\nisRegExp()\n\n\nassert.isRegExp(actual[, message])\n\n\n\n\nFails if \nactual\n is not an instance of \nRegExp\n.\n\n\nassert.isRegExp(new RegExp(\napple pie\n));  // Passes\nassert.isRegExp(/apple pie/);              // Passes\nassert.isRegExp(\napple pie\n);              // Fails\n\n\n\n\nMessages\n\n\nassert.isRegExp.message = \nExpected ${actual} to be an RegExp\n;\nrefute.isRegExp.message = \nExpected ${actual} not to be an RegExp\n;\n\n\n\n\nisSet()\n\n\nassert.isSet(actual[, message])\n\n\n\n\nFails if \nactual\n is not an instance of \nSet\n.\n\n\nassert.isSet(new Set());  // Passes\nassert.isSet([]);         // Fails\n\n\n\n\nMessages\n\n\nassert.isSet.message = \nExpected ${actual} to be a Set\n;\nrefute.isSet.message = \nExpected ${actual} not to be a Set\n;\n\n\n\n\nisSymbol()\n\n\nassert.isSymbol(actual[, message])\n\n\n\n\nFails if \nactual\n is not a value of type \nSymbol\n.\n\n\nassert.isSymbol(Symbol(\napple pie\n));  // Passes\nassert.isSymbol(\napple pie\n);          // Fails\n\n\n\n\nMessages\n\n\nassert.isSymbol.message = \nExpected ${actual} to be a Symbol\n;\nrefute.isSymbol.message = \nExpected ${actual} not to be a Symbol\n;\n\n\n\n\nisSyntaxError()\n\n\nassert.isSyntaxError(actual[, message])\n\n\n\n\nFails if \nactual\n is not an instance of \nSyntaxError\n.\n\n\nassert.isSyntaxError(new SyntaxError(\nthis is a syntax error\n));  // Passes\nassert.isSyntaxError(new Error(\nthis is not a syntax error\n));    // Fails\n\n\n\n\nMessages\n\n\nassert.isSyntaxError.message = \nExpected ${actual} to be a SyntaxError\n;\nrefute.isSyntaxError.message = \nExpected ${actual} not to be a SyntaxError\n;\n\n\n\n\nisTypeError()\n\n\nassert.isTypeError(actual[, message])\n\n\n\n\nFails if \nactual\n is not an instance of \nTypeError\n.\n\n\nassert.isTypeError(new TypeError(\nthis is a type error\n));  // Passes\nassert.isTypeError(new Error(\nthis is not a type error\n));  // Fails\n\n\n\n\nMessages\n\n\nassert.isTypeError.message = \nExpected ${actual} to be a TypeError\n;\nrefute.isTypeError.message = \nExpected ${actual} not to be a TypeError\n;\n\n\n\n\nisURIError()\n\n\nassert.isURIError(actual[, message])\n\n\n\n\nFails if \nactual\n is not an instance of \nURIError\n.\n\n\nassert.isURIError(new URIError(\nthis is a uri error\n));  // Passes\nassert.isURIError(new Error(\nthis is not a uri error\n)); // Fails\n\n\n\n\nMessages\n\n\nassert.isURIError.message = \nExpected ${actual} to be a URIError\n;\nrefute.isURIError.message = \nExpected ${actual} not to be a URIError\n;\n\n\n\n\nisUint16Array()\n\n\nassert.isUint16Array(actual[, message])\n\n\n\n\nFails if \nactual\n is not an instance of \nUint16Array\n.\n\n\nassert.isUint16Array(new Uint16Array());  // Passes\nassert.isUint16Array(new Uint32Array());  // Fails\nassert.isUint16Array(new Uint8Array());   // Fails\n\n\n\n\nMessages\n\n\nassert.isUint16Array.message = \nExpected ${actual} to be a Uint16Array\n;\nrefute.isUint16Array.message = \nExpected ${actual} not to be a Uint16Array\n;\n\n\n\n\nisUint32Array()\n\n\nassert.isUint32Array(actual[, message])\n\n\n\n\nFails if \nactual\n is not an instance of \nUint32Array\n.\n\n\nassert.isUint32Array(new Uint16Array());  // Fails\nassert.isUint32Array(new Uint32Array());  // Passes\nassert.isUint32Array(new Uint8Array());   // Fails\n\n\n\n\nMessages\n\n\nassert.isUint32Array.message = \nExpected ${actual} to be a Uint32Array\n;\nrefute.isUint32Array.message = \nExpected ${actual} not to be a Uint32Array\n;\n\n\n\n\nisUint8Array()\n\n\nassert.isUint8Array(actual[, message])\n\n\n\n\nFails if \nactual\n is not an instance of \nUint8Array\n.\n\n\nassert.isUint8Array(new Uint16Array());  // Fails\nassert.isUint8Array(new Uint32Array());  // Fails\nassert.isUint8Array(new Uint8Array());   // Passes\n\n\n\n\nMessages\n\n\nassert.isUint8Array.message = \nExpected ${actual} to be a Uint8Array\n;\nrefute.isUint8Array.message = \nExpected ${actual} not to be a Uint8Array\n;\n\n\n\n\nisUint8ClampedArray()\n\n\nassert.isUint8ClampedArray(actual[, message])\n\n\n\n\nFails if \nactual\n is not an instance of \nUint8ClampedArray\n.\n\n\nassert.isUint8ClampedArray(new Uint8ClampedArray());   // Passes\nassert.isUint8ClampedArray(new Uint8Array());          // Fails\n\n\n\n\nMessages\n\n\nassert.isUint8ClampedArray.message = \nExpected ${actual} to be a Uint8ClampedArray\n;\nrefute.isUint8ClampedArray.message = \nExpected ${actual} not to be a Uint8ClampedArray\n;\n\n\n\n\nisWeakMap()\n\n\nassert.isWeakMap(actual[, message])\n\n\n\n\nFails if \nactual\n is not an instance of \nWeakMap\n.\n\n\nassert.isWeakMap(new WeakMap());   // Passes\nassert.isWeakMap(new Map());       // Fails\n\n\n\n\nMessages\n\n\nassert.isWeakMap.message = \nExpected ${actual} to be a WeakMap\n;\nrefute.isWeakMap.message = \nExpected ${actual} not to be a WeakMap\n;\n\n\n\n\nisWeakSet()\n\n\nassert.isWeakSet(actual[, message])\n\n\n\n\nFails if \nactual\n is not an instance of \nWeakSet\n.\n\n\nassert.isWeakSet(new WeakSet());   // Passes\nassert.isWeakSet(new Set());       // Fails\n\n\n\n\nMessages\n\n\nassert.isWeakSet.message = \nExpected ${actual} to be a WeakSet\n;\nrefute.isWeakSet.message = \nExpected ${actual} not to be a WeakSet\n;\n\n\n\n\nkeys()\n\n\nassert.keys(object, keyArray[, message])\n\n\n\n\nFails if object\u2019s own properties are not exactly the same as a given list.\n\n\nassert.keys({ test1: 't1', test2: 't2' }, ['test1']);                 // Fails - 'test2' is unexpected\nassert.keys({ test1: 't1', test2: 't2' }, ['test1','test2','test3']); // Fails - 'test3' is not present\nassert.keys({ test1: 't1', test2: 't2' }, ['test1','test2']);         // Passes\n\n\n\n\nMessages\n\n\nassert.keys.message = \nExpected ${actualObject} to have exact keys ${keys}\n;\nrefute.keys.message = \nExpected not to have exact keys ${keys}\n;\n\n\n\n\nexception()\n\n\nassert.exception(callback[, matcher, message])\n\n\n\n\nFails if \ncallback\n does not throw an exception. If the optional \nmatcher\n is provided, the assertion fails if the callback either does not throw an exception, or if the exception does not meet the criterias of the given `matcher.\n\n\nThe \nmatcher\n can be of type \nobject\n or \nfunction\n. If the \nmatcher\n is of type \nobject\n, the captured error object and the \nmatcher\n are passed to \nmatch()\n.\n\n\nIf the \nmatcher\n is of type \nfunction\n, the captured error object is passed as argument to the \nmatcher\n function, which has to return \ntrue\n for a matching error object, otherwise \nfalse\n.\n\n\n// Passes\nassert.exception(function () {\n    throw new Error(\nOoops!\n);\n});\n\n// Fails\nassert.exception(function () {});\n\n// Passes\nassert.exception(function () {\n    throw new TypeError(\nOoops!\n);\n},  { name: \nTypeError\n });\n\n// Fails, wrong exception type\nassert.exception(function () {\n    throw new Error(\nAww\n);\n}, { name: \nTypeError\n });\n\n// Fails, wrong exception message\nassert.exception(function () {\n    throw new Error(\nAww\n);\n}, { message: \nOoops!\n });\n\n// Fails, wrong exception type\nassert.exception(function () {\n    throw new Error(\nAww\n);\n}, function (err) {\n    if (err.name !== \nTypeError\n) {\n        return false;\n    }\n    return true;\n}, \nType of exception is wrong!\n);  // with message to print, if test fails\n\n\n\n\nMessages\n\n\nassert.exception.typeNoExceptionMessage = \nExpected ${expected} but no exception was thrown\n;\nassert.exception.message = \nExpected exception\n;\nassert.exception.typeFailMessage = \nExpected ${expected} but threw ${actualExceptionType} (${actualExceptionMessage})\\n${actualExceptionStack}\n;\nassert.exception.matchFailMessage = \nExpected thrown ${actualExceptionType} (${actualExceptionMessage}) to pass matcher function\n;\nrefute.exception.message = \nExpected not to throw but threw ${actualExceptionType} (${actualExceptionMessage})\n;\n\n\n\n\nnear()\n\n\nassert.near(actual, expected, delta[, message])\n\n\n\n\nFails if the difference between \nactual\n and \nexpected\n is greater than \ndelta\n.\n\n\nassert.near(10.3, 10, 0.5); // Passes\nassert.near(10.5, 10, 0.5); // Passes\nassert.near(10.6, 10, 0.5); // Fails\n\n\n\n\nMessages\n\n\nassert.near.message = \nExpected ${actual} to be equal to ${expected} +/- ${delta}\n;\nrefute.near.message = \nExpected ${actual} not to be equal to ${expected} +/- ${delta}\n;\n\n\n\n\nhasPrototype()\n\n\nassert.hasPrototype(actual, prototype[, message])\n\n\n\n\nFails if \nprototype\n does not exist in the prototype chain of \nactual\n.\n\n\nassert.hasPrototype(function() {}, Function.prototype); // Passes\nassert.hasPrototype(function() {}, Object.prototype);   // Passes\nassert.hasPrototype({}, Function.prototype);            // Fails\n\n\n\n\nMessages\n\n\nassert.hasPrototype.message = \nExpected ${actual} to have ${expected} on its prototype chain\n;\nrefute.hasPrototype.message = \nExpected ${actual} not to have ${expected} on its prototype chain\n;\n\n\n\n\ncontains()\n\n\nassert.contains(haystack, needle[, message])\n\n\n\n\nFails if the array like object \nhaystack\n does not contain the \nneedle\n argument.\n\n\nassert.contains([1, 2, 3], 2);   // Passes\nassert.contains([1, 2, 3], 4);   // Fails\nassert.contains([1, 2, 3], \n2\n); // Fails\n\n\n\n\nMessages\n\n\nassert.contains.message = \nExpected [${actual}] to contain ${expected}\n;\nrefute.contains.message = \nExpected [${actual}] not to contain ${expected}\n;\n\n\n\n\ntagName()\n\n\nassert.tagName(element, tagName[, message])\n\n\n\n\nFails if the \nelement\n either does not specify a \ntagName\n property, or if its value is not a case-insensitive match with the expected \ntagName\n. Works with any object.\n\n\nassert.tagName(document.createElement(\np\n), \np\n); // Passes\nassert.tagName(document.createElement(\nh2\n), \nH2\n); // Passes\nassert.tagName(document.createElement(\np\n), \nli\n);  // Fails\n\n\n\n\nMessages\n\n\nassert.tagName.noTagNameMessage = \nExpected ${actualElement} to have tagName property\n;\nassert.tagName.message = \nExpected tagName to be ${expected} but was ${actual}\n;\nrefute.tagName.noTagNameMessage = \nExpected ${actualElement} to have tagName property\n;\nrefute.tagName.refuteMessage = \nExpected tagName not to be ${actual}\n;\n\n\n\n\nclassName()\n\n\nassert.className(element, classNames[, message])\n\n\n\n\nFails if the \nelement\n either does not specify a \nclassName\n property, or if its value is not a space-separated list of all class names in \nclassNames\n.\n\n\nclassNames\n can be either a space-delimited string or an array of class names. Every class specified by classNames must be found in the object\u2019s \nclassName\n property for the assertion to pass, but order does not matter.\n\n\nvar el = document.createElement(\np\n);\nel.className = \nfeed item blog-post\n;\n\nassert.className(el, \nitem\n);           // Passes\nassert.className(el, \nnews\n);           // Fails\nassert.className(el, \nblog-post feed\n); // Passes\nassert.className(el, \nfeed items\n);     // Fails, \nitems\n is not a match\nassert.className(el, [\nitem\n, \nfeed\n]); // Passes\n\n\n\n\nMessages\n\n\nassert.className.noClassNameMessage = \nExpected object to have className property\n;\nassert.className.message = \nExpected object's className to include ${expected} but was ${actual}\n;\nrefute.className.noClassNameMessage = \nExpected object to have className property\n;\nrefute.className.message = \nExpected object's className not to include ${expected}\n;\n\n\n\n\njson()\n\n\nassert.json(actual, json[, message])\n\n\n\n\nFails if \nactual\n is not valid JSON or the parsed JSON is not equal to \njson\n. Uses the same comparison algorithm as \nequals()\n.\n\n\nvar serialized = JSON.stringify({ is: 42 });\n\nassert.json(serialized, { is: 42 }); // Passes\nassert.json(serialized, { or: 42 }); // Fails\nassert.json(serialized, { is: 7 });  // Fails\nassert.json(\nno-json\n, {});          // Fails\n\n\n\n\nMessages\n\n\nassert.json.message = \nExpected ${actual} to equal ${expected}\n;\nassert.json.jsonParseExceptionMessage = \nExpected ${actual} to be valid JSON\n;\nrefute.json.message = \nExpected ${actual} not to equal ${expected}\n;\nrefute.json.jsonParseExceptionMessage = \nExpected ${actual} to be valid JSON\n;\n\n\n\n\nmatchJson()\n\n\nassert.matchJson(actual, json[, message])\n\n\n\n\nFails if \nactual\n is not valid JSON or the parsed JSON does not match \njson\n. Uses the same matcher algorithm as \nmatch()\n.\n\n\nvar serialized = JSON.stringify({ is: 42, and: 3 });\n\nassert.matchJson(serialized, { is: 42 }); // Passes\nassert.matchJson(serialized, { and: 3 }); // Passes\nassert.matchJson(serialized, { or: 42 }); // Fails\nassert.matchJson(serialized, { is: 7 });  // Fails\nassert.matchJson(\nno-json\n, {});          // Fails\n\n\n\n\nMessages\n\n\nassert.json.message = \nExpected ${actual} to match ${expected}\n;\nassert.json.jsonParseExceptionMessage = \nExpected ${actual} to be valid JSON\n;\nrefute.json.message = \nExpected ${actual} not to match ${expected}\n;\nrefute.json.jsonParseExceptionMessage = \nExpected ${actual} to be valid JSON\n;\n\n\n\n\nCustom assertions\n\n\nCustom, domain-specific assertions helps improve clarity and reveal intent in tests. They also facilitate much better feedback when they fail. You can add custom assertions that behave exactly like the built-in ones (i.e. with counting, message formatting, expectations and\nmore) by using the \nreferee.add\n method.\n\n\nOverriding assertion messages\n\n\nThe default assertion messages can be overridden. The messages to\noverwrite are listed with each assertion. You can use the same keys for\nstring interpolation (e.g. \n${actual}\n, \n${expected}\n). equals:\n\n\nvar assert = require('referee').assert;\nassert.equals.message = \nI wanted ${actual} == ${expected}!\n\n\ntry {\n    assert.equals(3, 4);\n} catch (e) {\n    console.log(e.message);\n}\n\n// Prints:\n// \nI wanted 3 == 4!\n\n\n\n\n\nEvents\n\n\nreferee\n is an event-emitter. Listen to events with \non\n:\n\n\nreferee.on(\nfailure\n, function (err) {\n    console.log(err.message);\n});\n\n\n\n\npass\n event\n\n\nSignature:\n\n\npass\n, function () {}\n\n\n\n\nAssertion passed. The callback is invoked with the assertion name, e.g.\n\n\"equals\"\n, as its only argument. Note that this event is also emitted\nwhen refutations pass.\n\n\nfailure\n event\n\n\nSignature:\n\n\n    \nfailure\n, function (error) {}\n\n\n\n\nAssertion failed. The callback is invoked with an \nAssertionError\n object.\n\n\nSinon.JS\n integration\n\n\nYou can extend \nreferee\n with assertions that integrates with \nSinon.JS\n\n\nSee \nreferee-sinon\n\n\nExpectations\n\n\nAll of referee's assertions and refutations are also exposed as \"expectations\". Expectations is just a slightly different front-end to the same functionality, often preferred by the BDD inclined.\n\n\nExpectations mirror assertions under different names. Refutations can be expressed using \nexpect(obj).not\n and then calling either of the expectations on the resulting object.\n\n\nvar expect = require('referee').expect;\n\nexpect({ id: 42 }).toBeObject(); // Passes\nexpect(\nSomewhere in here\n).toMatch(\nin\n); // Passes\nexpect(42).not.toEqual(43); // Passes\n\n\n\n\nexpect.toBe()\n\n\nexpect(actual).toBe(expected)\n\n\n\n\nSee \nsame()\n\n\nexpect.toEqual()\n\n\nexpect(actual).toEqual(expected)\n\n\n\n\nSee \nequals()\n\n\nexpect.toBeGreaterThan()\n\n\nexpect(actual).toBeGreaterThan(expected)\n\n\n\n\nSee \ngreater()\n\n\nexpect.toBeLessThan()\n\n\nexpect(actual).toBeLessThan(expected)\n\n\n\n\nSee \nless()\n\n\nexpect.toBeDefined()\n\n\nexpect(actual).toBeDefined(expected)\n\n\n\n\nSee \ndefined()\n\n\nexpect.toBeNull()\n\n\nexpect(actual).toBeNull(expected)\n\n\n\n\nSee \nisNull()\n\n\nexpect.toMatch()\n\n\nexpect(actual).toMatch(expected)\n\n\n\n\nSee \nmatch()\n\n\n`expect.toBeObject()``\n\n\nexpect(actual).toBeObject(expected)\n\n\n\n\nSee \nisObject()\n\n\nexpect.toBeFunction()\n\n\nexpect(actual).toBeFunction(expected)\n\n\n\n\nSee \nisFunction()\n\n\nexpect.toBeTrue()\n\n\nexpect(actual).toBeTrue()\n\n\n\n\nSee \nisTrue()\n\n\nexpect.toBeFalse()\n\n\nexpect(actual).toBeFalse()\n\n\n\n\nSee \nisFalse()\n\n\nexpect.toBeString()\n\n\nexpect(actual).toBeString()\n\n\n\n\nSee \nisString()\n\n\nexpect.toBeBoolean()\n\n\nexpect(actual).toBeBoolean()\n\n\n\n\nSee \nisBoolean()\n\n\nexpect.toBeNumber()\n\n\nexpect(actual).toBeNumber()\n\n\n\n\nSee \nisNumber()\n\n\nexpect.toBeNaN()\n\n\nexpect(actual).toBeNaN()\n\n\n\n\nSee \nisNaN()\n\n\nexpect.toBeArray()\n\n\nexpect(actual).toBeArray()\n\n\n\n\nSee \nisArray()\n\n\nexpect.toBeArrayLike()\n\n\nexpect(actual).toBeArrayLike()\n\n\n\n\nSee \nisArrayLike()\n\n\nexpect.toHaveKeys()\n\n\nexpect(object).toHaveKeys(keyArray)\n\n\n\n\nSee \nkeys()\n\n\nexpect.toThrow()\n\n\nexpect(actual).toThrow(expected)\n\n\n\n\nSee \nexception()\n\n\nexpect.toBeNear()\n\n\nexpect(actual).toBeNear(expected, delta)\n\n\n\n\nSee \nnear()\n\n\nexpect.toHavePrototype()\n\n\nexpect(actual).toHavePrototype(prototype)\n\n\n\n\nSee \nhasPrototype()\n\n\nexpect.toContain()\n\n\nexpect(haystack).toContain(needle)\n\n\n\n\nSee \ncontains()\n\n\nexpect.toHaveTagName()\n\n\nexpect(actual).toHaveTagName(expected)\n\n\n\n\nSee \ntagName()\n\n\nexpect.toHaveClassName()\n\n\nexpect(actual).toHaveClassName(expected)\n\n\n\n\nSee \nclassName()\n\n\nexpect.toEqualJson()\n\n\nexpect(actual).toEqualJson(expected)\n\n\n\n\nSee \njson()\n\n\nexpect.toMatchJson()\n\n\nexpect(actual).toMatchJson(expected)\n\n\n\n\nSee \nmatchJson()\n\n\nexpect.toHaveBeenCalled()\n\n\nexpect(spy).toHaveBeenCalled()\n\n\n\n\nSee \ncalled()\n\n\nexpect.toHaveBeenCalledOnce()\n\n\nexpect(spy).toHaveBeenCalledOnce(expected)\n\n\n\n\nSee \ncalledOnce()\n\n\nexpect.toHaveBeenCalledTwice()\n\n\nexpect(spy).toHaveBeenCalledTwice(expected)\n\n\n\n\nSee \ncalledTwice()\n\n\nexpect.toHaveBeenCalledThrice()\n\n\nexpect(spy).toHaveBeenCalledThrice(expected)\n\n\n\n\nSee \ncalledThrice()\n\n\nexpect.toHaveBeenCalledWith()\n\n\nexpect(spy).toHaveBeenCalledWith(arg1, arg2, ...)\n\n\n\n\nSee \ncalledWith()\n\n\nexpect.toHaveBeenCalledOnceWith()\n\n\nexpect(spy).toHaveBeenCalledOnceWith(arg1, arg2, ...)\n\n\n\n\nSee \ncalledOnceWith()\n\n\nMethods\n\n\nreferee.fail()\n\n\nreferee.fail(message)\n\n\n\n\nWhen an assertion fails, it calls \nreferee.fail()\n with the failure message as the only argument. The built-in \nfail\n function both throws an \nAssertionError()\n and emits it to the \nfailure\n event. The error can be caught and handled by the test runner. If this behavior is not suitable for your testing framework of choice, you can override \nreferee.fail()\n to make it do the right thing.\n\n\nExample: To use `referee with JsTestDriver, you can simply configure it as follows:\n\n\nreferee.fail = function (message) {\n    fail(message);\n};\n\n\n\n\nWhere the global \nfail\n function is the one provided by JsTestDriver.\n\n\nIt is possible to make the default \nassert.fail\n method only emit an event and not throw an error. This may be suitable in asynchronous test runners, where you might not be able to catch exceptions. To silence exceptions, see the \nthrowOnFailure\n property.\n\n\nreferee.format()\n\n\nreferee.format(object)\n\n\n\n\nValues inserted into assertion messages using the \n${n}\n switches are formatted using \nreferee.format()\n. By default this method simply coerces the object to a string.\n\n\nA more expressive option is to use \nbuster-format\n, which is a generic function for formatting objects nicely as ASCII. For nice ASCII formatting of objects (including DOM elements) do:\n\n\nreferee.format = buster.format.ascii;\n\n\n\n\nreferee.add()\n\n\nreferee.add(name, options)\n\n\n\n\nAdd a custom assertion. Using this \u2018macro\u2019 to add project specific assertions has a few advantages:\n\n\n\n\nAssertions will be counted\n\n\nFailure messages will have interpolated arguments formatted by \nreferee.format()\n\n\nA single function generates both an assertion and a refutation\n\n\nIf using expectations, an expectation can easily be generated as well\n\n\nWhen \nfailOnNoAssertions\n is set to \ntrue\n, the assertion will behave correctly (may be important for asynchronous tests)\n\n\nThe assertion will fail if too few arguments are passed\n\n\n\n\nHere\u2019s an example of adding a \u201cfoo\u201d assertion, that only passes when its only argument is the string \u201cfoo\u201d:\n\n\nvar assert = referee.assert;\nvar refute = referee.refute;\nvar expect = referee.expect;\n\nreferee.add(\nisFoo\n, {\n    assert: function (actual) {\n        return actual == \nfoo\n;\n    },\n    assertMessage: \nExpected ${0} to be foo!\n,\n    refuteMessage: \nExpected not to be foo!\n,\n    expectation: \ntoBeFoo\n\n});\n\n// Now you can do:\n// Passes\nassert.isFoo(\nfoo\n);\n\n// Fails: \n[assert.isFoo] Expected { id: 42 } to be foo!\n\nassert.isFoo({ id: 42 });\n\n// Fails: \n[refute.isFoo] Expected not to be foo!\n\nrefute.isFoo(\nfoo\n);\n\n// Passes\nexpect(\nfoo\n).toBeFoo();\n\n// To support custom messages, do this:\nreferee.add(\nisFoo\n, {\n    assert: function (actual) {\n        return actual == \nfoo\n;\n    },\n    assertMessage: \n${1}Expected ${0} to be foo!\n,\n    refuteMessage: \n${1}Expected not to be foo!\n,\n    expectation: \ntoBeFoo\n,\n    values: function (thing, message) {\n        return [thing, message ? message + \n \n : \n];\n    }\n});\n\n// Fails: \n[assert.isFoo] Ouch: Expected { id: 42 } to be foo!\n\nassert.isFoo({ id: 42 }, \nOuch\n);\n\n\n\n\nError message value interpolation\n\n\nArguments are available in assertion failure messages using the \n\"${n}\"\n switches, where \nn\n is a number. You can also use named variables by setting properties on \nthis\n in the assertion/refutation function:\n\n\nreferee.add(\nisString\n, {\n    assert: function (actual) {\n        this.actualType = typeof actual;\n        return this.actualType == \nstring\n;\n    },\n    assertMessage: \nExpected ${0} (${actualType}) to be string\n,\n    refuteMessage: \nExpected not to be string\n,\n    expectation: \ntoBeString\n\n});\n\n\n\n\nArguments\n\n\n\n    \n`name`:\n\n    \nThe name of the new assertion/refutation\n\n    \noptions\n\n    \n\n        \n\n            \n`assert`:\n\n            \n\nThe verification function. Should return `true` when the assertion passes. The generated refutation will pass when the function returns `false`.\n\nIn some cases the refutation may not be the exact opposite of the assertion. If that is the case you should provide `options.refute` for the custom refutation.\n\nThe number of formal parameters the function accepts determines the number of required arguments to the function. If the assertion is called with less arguments than expected, referee will fail it before your custom function is even called.\n\nAll arguments are available for interpolation into the resulting error message. The first argument will be available as `\"${0}\"`, the second as `\"${1}\"` and so on. If you want to embed other values than exact arguments into the string, you can set properties on this in the custom assertion, and refer to them as `\"${name}\"` in the message.\n            \n\n            \n`refute`:\n\n            \nCustom refutation function. Used over `!assert()` if provided.\n\n            \n`assertMessage`:\n\n            \nThe error message to use when the assertion fails. The message may refer to arguments through switches like `\"${0}\"`` and so on (see above, under the assert argument). The message is exposed on the generated assertion as the property `assert.[name].message`.\n\n            \n`refuteMessage`:\n\n            \nLike `assertMessage`, but for refutations. Exposed as `refute.[name].message`.\n\n            \n`values:`\n\n            \nA function that maps values to be interpolated into the failure messages. This can be used when you need something more/else than the actual `arguments` in order.\n\n            \nexpectation:\n\n            \nThe name of the assertion as an expectation, e.g. \u201ctoBeSomething\u201d. Optional.\n\n        \n\n    \n\n\n\n\n\nProperties\n\n\nreferee.count\n\n\nNumber\n increasing from 0.\n\n\nreferee.count\n is incremented anytime an assertion is called. The assertion counter can be reset to any number at your convenience.\n\n\n`referee.throwOnFailure\n\n\nBoolean\n.\n\n\nWhen using the default \nreferee.fail()\n implementation, this property can be set to \nfalse\n to make assertion failures not throw exceptions (i.e. only emit events). This may be suitable in asynchronous test runners, where you might not be able to catch exceptions.\n\n\nSupporting objects\n\n\nclass AssertionError()\n\n\nAn exception (specifically, an \nError\n object) whose \nname\n property is \n\"AssertionError\"\n.", 
            "title": "referee"
        }, 
        {
            "location": "/#referee", 
            "text": "A collection of assertions to be used with a unit testing framework.  referee  works well with any CommonJS compliant testing framework out of the box, and can easily be configured to work with most any testing framework. See also expectations if you like the alternative API\n( expect(thing).toBe* ).  referee  contains lots of assertions. We strongly believe that high-level assertions are essential in the interest of producing clear and intent-revealing tests, and they also give you to-the-point failure messages.", 
            "title": "referee"
        }, 
        {
            "location": "/#assertions-and-refutations", 
            "text": "Unlike most assertion libraries,  referee  does not have  assert.notXyz  assertions to refute some fact. Instead, it has  refutations , heavily inspired by Ruby's  minitest :  var assert = referee.assert;\nvar refute = referee.refute;\n\nassert.equals(42, 42);\nrefute.equals(42, 43);  Refutations help express \"assert not ...\" style verification in a much clearer way. It also brings with it a nice consistency in that any  assert.xyz  always has a corresponding  refute.xyz  that does the opposite check.", 
            "title": "Assertions and refutations"
        }, 
        {
            "location": "/#assert", 
            "text": "assert(actual[, message]);  Fails if  actual  is falsy ( 0 ,  \"\" ,  null ,  undefined ,  NaN ). Fails with either the provided message or \"Expected null to be truthy\". This behavior differs from all other assertions, which prepend the optional message argument.  assert({ not:  Falsy  },  This will pass );\nassert(null,  This will fail ); // Fails with custom message\nassert(null); // Fails\nassert(34);   // Passes", 
            "title": "assert()"
        }, 
        {
            "location": "/#refute", 
            "text": "refute(actual[, message])  Fails if actual is truthy. Fails with either the provided message or \"Expected null to be falsy\". This behavior differs from all other refutations, which prepend the optional message argument.  refute({ not:  Falsy  },  This will fail ); // Fails with custom message\nrefute(null,  This will pass );\nrefute(null); // Passes\nrefute(34);   // Fails", 
            "title": "refute()"
        }, 
        {
            "location": "/#predefined-assertions", 
            "text": "The following assertions can be used with  assert  and  refute . They\nare described for  assert , but the corresponding failure messages for refute  are also mentioned. For  refute  the behaviour is exactly\nopposed.  All assertions support an optional  message  argument, which is\nprepended to the failure message.  Overview:   same()  equals()  greater()  less()  defined()  isNull()  match()  exception()  near()  hasPrototype()  contains()  tagName()  className()  json()   matchJson()    isArray()   isArrayBuffer()  isArrayLike()  isBoolean()  isDataView()  isDate()  isError()  isEvalError()  isFalse()  isFloat32Array()  isFloat64Array()  isFunction()  isInfinity()  isIntlCollator()  isIntlDateTimeFormat()  isIntlNumberFormat()  isMap()  isNaN()  isNull()  isNumber()  isObject()  isPromise()  isRangeError()  isReferenceError()  isRegExp()  isSet()  isString()  isSymbol()  isSyntaxError()  isTrue()  isTypeError()  isUint16Array()  isUint32Array()  isUint8Array()  isUint8Array()  isUint8clampedArray()  isURIError()  isWeakMap()  isWeakSet()", 
            "title": "Predefined Assertions"
        }, 
        {
            "location": "/#same", 
            "text": "assert.same(actual, expected[, message])  Fails if  actual  is not the same object ( === ) as  expected . To compare similar objects, such as { name: \"Chris\", id: 42 } and { id: 42, name: \"Chris\" } (not the same instance), see  equals() .  var obj = { id: 42, name:  Chris  };\nassert.same(obj, obj);                       // Passes\nassert.same(obj, { id: 42, name:  Chris  }); // Fails", 
            "title": "same()"
        }, 
        {
            "location": "/#messages", 
            "text": "assert.same.message =  ${actual} expected to be the same object as ${expected} ;\nrefute.same.message =  ${actual} expected not to be the same object as ${expected} ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#equals", 
            "text": "assert.equals(actual, expected[, message])  Compares  actual  to  expected  property by property. If the property count does not match, or if any of  actual \u2018s properties do not match the corresponding property in  expected , the assertion fails. Object properties are verified recursively.  If  actual  is  null  or  undefined , an exact match is required. Date objects are compared by their  getTime  method. Regular expressions are compared by their string representations. Primitives are compared using  == , i.e., with coercion.  equals  passes when comparing an arguments object to an array if the both contain the same elements.  assert.equals({ name:  Professor Chaos  }, { name:  Professor Chaos  }); // Passes\nassert.equals({ name:  Professor Chaos  }, { name:  Dr Evil  }); // Fails", 
            "title": "equals()"
        }, 
        {
            "location": "/#messages_1", 
            "text": "assert.equals.message =  ${actual} expected to be equal to ${expected} ;\nrefute.equals.message =  ${actual} expected not to be equal to ${expected} ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#greater", 
            "text": "assert.greater(actual, expected[, message])  Fails if  actual  is equal to or less than  expected .  assert.greater(2, 1); // Passes\nassert.greater(1, 1); // Fails\nassert.greater(1, 2); // Fails", 
            "title": "greater()"
        }, 
        {
            "location": "/#messages_2", 
            "text": "assert.greater.message =  Expected ${actual} to be greater than ${expected} ;\nrefute.greater.message =  Expected ${actual} to be less than or equal to ${expected} ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#less", 
            "text": "assert.less(actual, expected[, message])  Fails if  actual  is equal to or greater than  expected .  assert.less(1, 2); // Passes\nassert.less(1, 1); // Fails\nassert.less(2, 1); // Fails", 
            "title": "less()"
        }, 
        {
            "location": "/#messages_3", 
            "text": "assert.less.message =  Expected ${actual} to be less than ${expected} ;\nrefute.less.message =  Expected ${actual} to be greater than or equal to ${expected} ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#defined", 
            "text": "assert.defined(object[, message])  Fails if  object  is undefined.  var a;\nassert.defined({});  // Passes\nassert.defined(a); // Fails", 
            "title": "defined()"
        }, 
        {
            "location": "/#messages_4", 
            "text": "assert.defined.message =  Expected to be defined ;\nrefute.defined.message =  Expected ${actual} (${actualType}) not to be defined ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#isnull", 
            "text": "assert.isNull(object[, message])  Fails if  object  is not  null .  assert.isNull(null,  This will pass );\nassert.isNull({},  This will fail );\nassert.isNull(null); // Passes\nassert.isNull({});   // Fails", 
            "title": "isNull()"
        }, 
        {
            "location": "/#messages_5", 
            "text": "assert.isNull.message =  Expected ${actual} to be null ;\nrefute.isNull.message =  Expected not to be null ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#match", 
            "text": "assert.match(actual, matcher[, message])  Fails if  matcher  is not a partial match for  actual . Accepts a wide range of input combinations. Note that  assert.match  is not symmetric - in some cases  assert.match(a, b)  may pass while  assert.match(b, a)  fails.", 
            "title": "match()"
        }, 
        {
            "location": "/#string-matcher", 
            "text": "In its simplest form,  assert.match  performs a case insensitive substring match. When the matcher is a string, the  actual  object is converted to a string, and the assertion passes if  actual  is a case-insensitive substring of expected as a string.  assert.match( Give me something ,  Give );                           // Passes\nassert.match( Give me something ,  sumptn );                         // Fails\nassert.match({ toString: function () { return  yeah ; } },  Yeah! ); // Passes  The last example is not symmetric. When the matcher is a string, the actual value is coerced to a string - in this case using  toString . Changing the order of the arguments would cause the matcher to be an object, in which case different rules apply (see below).", 
            "title": "String matcher"
        }, 
        {
            "location": "/#boolean-matcher", 
            "text": "Performs a strict (i.e.  === ) match with the object. So, only  true  matches  true , and only  false  matches  false .", 
            "title": "Boolean matcher"
        }, 
        {
            "location": "/#regular-expression-matcher", 
            "text": "When the matcher is a regular expression, the assertion will pass if  expected.test(actual)  is  true .  assert.match  is written in a generic way, so any object with a  test  method will be used as a matcher this way.  assert.match( Give me something , /^[a-z\\s]$/i); // Passes\nassert.match( Give me something , /[0-9]/); // Fails\nassert.match({ toString: function () { return  yeah! ; } }, /yeah/); // Passes\nassert.match(234, /[a-z]/); // Fails", 
            "title": "Regular expression matcher"
        }, 
        {
            "location": "/#number-matcher", 
            "text": "When the matcher is a number, the assertion will pass if  matcher == actual .  assert.match( 123 , 123); // Passes\nassert.match( Give me something , 425); // Fails\nassert.match({ toString: function () { return  42 ; } }, 42); // Passes\nassert.match(234, 1234); // Fails", 
            "title": "Number matcher"
        }, 
        {
            "location": "/#function-matcher", 
            "text": "When the matcher is a function, it is called with  actual  as its only argument. The assertion will pass if the function returns  true . A strict match is performed against the return value, so a boolean  true  is required, truthy is not enough.  // Passes\nassert.match( 123 , function (exp) {\n    return exp ==  123 ;\n});\n\n// Fails\nassert.match( Give me something , function () {\n    return  ok ;\n});\n\n// Passes\nassert.match({\n    toString: function () {\n        return  42 ;\n    }\n}, function () { return true; });\n\n// Fails\nassert.match(234, function () {});", 
            "title": "Function matcher"
        }, 
        {
            "location": "/#object-matcher", 
            "text": "As mentioned above, if an object matcher defines a test method the assertion will pass if  matcher.test(actual)  returns truthy. If the object does not have a  test  method, a recursive match is performed. If all properties of  matcher  matches corresponding properties in  actual , the assertion passes. Note that the object matcher does not care if the number of properties in the two objects are the same - only if all properties in the matcher recursively \u201cmatches\u201d ones in the actual object.  // Passes\nassert.match( 123 , {\n    test: function (arg) {\n        return arg == 123;\n    }\n});\n\n// Fails\nassert.match({}, { prop: 42 });\n\n// Passes\nassert.match({\n    name:  Chris ,\n    profession:  Programmer \n}, {\n    name:  Chris \n});\n\n// Fails\nassert.match(234, {\n    name:  Chris \n});", 
            "title": "Object matcher"
        }, 
        {
            "location": "/#dom-elements", 
            "text": "assert.match  can be very helpful when asserting on DOM elements, because it allows you to compare several properties with one assertion:  var el = document.getElementById( myEl );\n\nassert.match(el, {\n    tagName:  h2 ,\n    className:  item ,\n    innerHTML:  Howdy \n});", 
            "title": "DOM elements"
        }, 
        {
            "location": "/#messages_6", 
            "text": "assert.match.exceptionMessage =  ${exceptionMessage} ;\nrefute.match.exceptionMessage =  ${exceptionMessage} ;  Used when the matcher function throws an exception. This happens if the matcher is not any of the accepted types, for instance, a boolean.  assert.match.message =  ${actual} expected to match ${expected} ;\nrefute.match.message =  ${actual} expected not to match ${expected} ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#isobject", 
            "text": "assert.isObject(object[, message])  Fails if  object  is not an object or if it is  null .  assert.isObject({});             // Passes\nassert.isObject(42);             // Fails\nassert.isObject([1, 2, 3]);      // Passes\nassert.isObject(function () {}); // Fails", 
            "title": "isObject()"
        }, 
        {
            "location": "/#messages_7", 
            "text": "assert.isObject.message =  ${actual} (${actualType}) expected to be object and not null ;\nrefute.isObject.message =  ${actual} expected to be null or not an object ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#isfunction", 
            "text": "assert.isFunction(actual[, message])  Fails if  actual  is not a function.  assert.isFunction({});             // Fails\nassert.isFunction(42);             // Fails\nassert.isFunction(function () {}); // Passes", 
            "title": "isFunction()"
        }, 
        {
            "location": "/#messages_8", 
            "text": "assert.isFunction.message =  ${actual} (${actualType}) expected to be function ;\nrefute.isFunction.message =  ${actual} expected not to be function ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#istrue", 
            "text": "assert.isTrue(actual[, message])  Fails if  actual  is not  true .  assert.isTrue( 2  == 2);  // Passes\nassert.isTrue( 2  === 2); // Fails", 
            "title": "isTrue()"
        }, 
        {
            "location": "/#messages_9", 
            "text": "assert.isTrue.message =  Expected ${actual} to be true ;\nrefute.isTrue.message =  Expected ${actual} to not be true ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#isfalse", 
            "text": "assert.isFalse(actual[, message])  Fails if  actual  is not  false .  assert.isFalse( 2  === 2); // Passes\nassert.isFalse( 2  == 2);  // Fails", 
            "title": "isFalse()"
        }, 
        {
            "location": "/#messages_10", 
            "text": "assert.isFalse.message =  Expected ${actual} to be false ;\nrefute.isFalse.message =  Expected ${actual} to not be false ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#isstring", 
            "text": "assert.isString(actual[, message])  Fails if the type of actual is not \"string\".  assert.isString( 2 ); // Passes\nassert.isString(2);   // Fails", 
            "title": "isString()"
        }, 
        {
            "location": "/#messages_11", 
            "text": "assert.isString.message =  Expected ${actual} (${actualType}) to be string ;\nrefute.isString.message =  Expected ${actual} not to be string ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#isboolean", 
            "text": "assert.isBoolean(actual[, message])  Fails if the type of  actual  is not \"boolean\".  assert.isBoolean(true);   // Passes\nassert.isBoolean(2   2);  // Passes\nassert.isBoolean( true ); // Fails", 
            "title": "isBoolean()"
        }, 
        {
            "location": "/#messages_12", 
            "text": "assert.isBoolean.message =  Expected ${actual} (${actualType}) to be boolean ;\nrefute.isBoolean.message =  Expected ${actual} not to be boolean ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#isnumber", 
            "text": "assert.isNumber(actual[, message])  Fails if the type of  actual  is not \"number\" or is  NaN .  assert.isNumber(12);   // Passes\nassert.isNumber( 12 ); // Fails\nassert.isNumber(NaN);  // Fails", 
            "title": "isNumber()"
        }, 
        {
            "location": "/#messages_13", 
            "text": "assert.isNumber.message =  Expected ${actual} (${actualType}) to be a non-NaN number ;\nrefute.isNumber.message =  Expected ${actual} to be NaN or a non-number value ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#isnan", 
            "text": "assert.isNaN(actual[, message])  Fails if  actual  is not  NaN . Does not perform coercion in contrast to the standard javascript function  isNaN .  assert.isNaN(NaN);           // Passes\nassert.isNaN( abc  /  def ); // Passes\nassert.isNaN(12);            // Fails\nassert.isNaN({});            // Fails, would pass for standard javascript function isNaN", 
            "title": "isNaN()"
        }, 
        {
            "location": "/#messages_14", 
            "text": "assert.isNaN.message =  Expected ${actual} to be NaN ;\nrefute.isNaN.message =  Expected not to be NaN ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#isarray", 
            "text": "assert.isArray(actual[, message])  Fails if the object type of  actual  is not  Array .  assert.isArray([1, 2, 3]); // Passes\nassert.isArray({});        // Fails", 
            "title": "isArray()"
        }, 
        {
            "location": "/#messages_15", 
            "text": "assert.isArray.message =  Expected ${actual} to be array ;\nrefute.isArray.message =  Expected ${actual} not to be array ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#isarraybuffer", 
            "text": "assert.isArrayBuffer(actual[, message])  Fails if the object type of  actual  is not  ArrayBuffer .  assert.isArrayBuffer(new ArrayBuffer(8)); // Passes\nassert.isArrayBuffer({});                 // Fails", 
            "title": "isArrayBuffer()"
        }, 
        {
            "location": "/#messages_16", 
            "text": "assert.isArrayBuffer.message =  Expected ${actual} to be an ArrayBuffer ;\nrefute.isArrayBuffer.message =  Expected ${actual} not to be an ArrayBuffer ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#isarraylike", 
            "text": "assert.isArrayLike(actual[, message])  Fails if none of the following conditions are fulfilled:   the object type of  actual  is  Array  actual  is an  arguments  object  actual  is an object providing a property  length  of type \"number\" and a  property  splice of type \"function\"   assert.isArrayLike([1, 2, 3]);                            // Passes\nassert.isArrayLike(arguments);                            // Passes\nassert.isArrayLike({ length: 0, splice: function() {} }); // Passes\nassert.isArrayLike({});                                   // Fails", 
            "title": "isArrayLike()"
        }, 
        {
            "location": "/#messages_17", 
            "text": "assert.isArrayLike.message =  Expected ${actual} to be array like ;\nrefute.isArrayLike.message =  Expected ${actual} not to be array like ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#isdataview", 
            "text": "assert.isDataView(actual[, message])  Fails if the object type of  actual  is not  DataView .  assert.isDataView(new DataView(new ArrayBuffer(16)); // Passes\nassert.isDataView({});                               // Fails", 
            "title": "isDataView()"
        }, 
        {
            "location": "/#messages_18", 
            "text": "assert.isDataView.message =  Expected ${actual} to be a DataView ;\nrefute.isDataView.message =  Expected ${actual} not to be a DataView ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#isdate", 
            "text": "assert.isDate(actual[, message])  Fails if  actual  is not an instance of  Date .  assert.isDate(new Date());  // Passes\nassert.isDate(12345678);    // Fails\nassert.isDate( apple pie ); // Fails", 
            "title": "isDate()"
        }, 
        {
            "location": "/#messages_19", 
            "text": "assert.isDate.message =  Expected ${actual} to be a Date ;\nrefute.isDate.message =  Expected ${actual} not to be a Date ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#iserror", 
            "text": "assert.isError(actual[, message])  Fails if  actual  is not an instance of  Error .\nPasses for all  built in error types  and errors derived from a built in error type.  assert.isError(new Error( this is an error ); // Passes\nassert.isError( this is not an error );       // Fails", 
            "title": "isError()"
        }, 
        {
            "location": "/#messages_20", 
            "text": "assert.isError.message =  Expected ${actual} to be an Error ;\nrefute.isError.message =  Expected ${actual} not to be an Error ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#isevalerror", 
            "text": "assert.isEvalError(actual[, message])  Fails if  actual  is not an instance of  EvalError .  assert.isEvalError(new EvalError( this is an eval error ));  // Passes\nassert.isEvalError(new Error( this is not an eval error )); // Fails", 
            "title": "isEvalError()"
        }, 
        {
            "location": "/#messages_21", 
            "text": "assert.isEvalError.message =  Expected ${actual} to be an EvalError ;\nrefute.isEvalError.message =  Expected ${actual} not to be an EvalError ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#isfloat32array", 
            "text": "assert.isFloat32Array(actual[, message])  Fails if  actual  is not an instance of  Float32Array .  assert.isFloat32Array(new Float32Array(2)); // Passes\nassert.isFloat32Array(new Float64Array(2)); // Fails", 
            "title": "isFloat32Array()"
        }, 
        {
            "location": "/#messages_22", 
            "text": "assert.isFloat32Array.message =  Expected ${actual} to be a Float32Array ;\nrefute.isFloat32Array.message =  Expected ${actual} not to be n Float32Array ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#isfloat64array", 
            "text": "assert.isFloat64Array(actual[, message])  Fails if  actual  is not an instance of  Float64Array .  assert.isFloat64Array(new Float64Array(2)); // Passes\nassert.isFloat64Array(new Float32Array(2)); // Fails", 
            "title": "isFloat64Array()"
        }, 
        {
            "location": "/#messages_23", 
            "text": "assert.isFloat64Array.message =  Expected ${actual} to be a Float64Array ;\nrefute.isFloat64Array.message =  Expected ${actual} not to be a Float64Array ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#isinfinity", 
            "text": "assert.isInfinity(actual[, message])  Fails if  actual  is not  Infinity .  assert.isInfinity(Infinity); // Passes\nassert.isInfinity(42);       // Fails", 
            "title": "isInfinity()"
        }, 
        {
            "location": "/#messages_24", 
            "text": "assert.isInfinity.message =  Expected ${actual} to be Infinity ;\nrefute.isInfinity.message =  Expected ${actual} not to be Infinity ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#isint8array", 
            "text": "assert.isInt8Array(actual[, message])  Fails if  actual  is not an instance of  Int8Array .  assert.isInt8Array(new Int8Array(2)); // Passes\nassert.isInt8Array(new Int16Array(2)); // Fails", 
            "title": "isInt8Array()"
        }, 
        {
            "location": "/#messages_25", 
            "text": "assert.isInt8Array.message =  Expected ${actual} to be an Int8Array ;\nrefute.isInt8Array.message =  Expected ${actual} not to be an Int8Array ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#isint16array", 
            "text": "assert.isInt16Array(actual[, message])  Fails if  actual  is not an instance of  Int16Array .  assert.isInt16Array(new Int16Array(2)); // Passes\nassert.isInt16Array(new Int32Array(2)); // Fails", 
            "title": "isInt16Array()"
        }, 
        {
            "location": "/#messages_26", 
            "text": "assert.isInt16Array.message =  Expected ${actual} to be an Int16Array ;\nrefute.isInt16Array.message =  Expected ${actual} not to be an Int16Array ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#isint32array", 
            "text": "assert.isInt32Array(actual[, message])  Fails if  actual  is not an instance of  Int32Array .  assert.isInt32Array(new Int32Array(2)); // Passes\nassert.isInt32Array(new Int16Array(2)); // Fails", 
            "title": "isInt32Array()"
        }, 
        {
            "location": "/#messages_27", 
            "text": "assert.isInt32Array.message =  Expected ${actual} to be an Int32Array ;\nrefute.isInt32Array.message =  Expected ${actual} not to be an Int32Array ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#isintlcollator", 
            "text": "assert.isIntlCollator(actual[, message])  Fails if  actual  is not an instance of  Intl.Collator .  assert.isIntlCollator(new Intl.Collator()); // Passes\nassert.isIntlCollator({});                   // Fails", 
            "title": "isIntlCollator()"
        }, 
        {
            "location": "/#messages_28", 
            "text": "assert.isIntlCollator.message =  Expected ${actual} to be an Intl.Collator ;\nrefute.isIntlCollator.message =  Expected ${actual} not to be an Intl.Collator ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#isintldatetimeformat", 
            "text": "assert.isIntlDateTimeFormat(actual[, message])  Fails if  actual  is not an instance of  Intl.DateTimeFormat .  assert.isIntlDateTimeFormat(new Intl.DateTimeFormat()); // Passes\nassert.isIntlDateTimeFormat({});                        // Fails", 
            "title": "isIntlDateTimeFormat()"
        }, 
        {
            "location": "/#messages_29", 
            "text": "assert.isIntlDateTimeFormat.message =  Expected ${actual} to be an Intl.DateTimeFormat ;\nrefute.isIntlDateTimeFormat.message =  Expected ${actual} not to be an Intl.DateTimeFormat ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#isintlnumberformat", 
            "text": "assert.isIntlNumberFormat(actual[, message])  Fails if  actual  is not an instance of  Intl.NumberFormat .  assert.isIntlNumberFormat(new Intl.NumberFormat()); // Passes\nassert.isIntlNumberFormat({});                      // Fails", 
            "title": "isIntlNumberFormat()"
        }, 
        {
            "location": "/#messages_30", 
            "text": "assert.isIntlNumberFormat.message =  Expected ${actual} to be an Intl.NumberFormat ;\nrefute.isIntlNumberFormat.message =  Expected ${actual} not to be an Intl.NumberFormat ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#ismap", 
            "text": "assert.Map(actual[, message])  Fails if  actual  is not an instance of  Map .  assert.isMap(new Map()); // Passes\nassert.isMap({});        // Fails", 
            "title": "isMap()"
        }, 
        {
            "location": "/#messages_31", 
            "text": "assert.isMap.message =  Expected ${actual} to be a Map ;\nrefute.isMap.message =  Expected ${actual} not to be a Map ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#ispromise", 
            "text": "assert.Promise(actual[, message])  Fails if  actual  is not an instance of  Promise .  assert.isPromise(new Promise()); // Passes\nassert.isPromise({});            // Fails", 
            "title": "isPromise()"
        }, 
        {
            "location": "/#messages_32", 
            "text": "assert.isPromise.message =  Expected ${actual} to be a Promise ;\nrefute.isPromise.message =  Expected ${actual} not to be a Promise ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#israngeerror", 
            "text": "assert.isRangeError(actual[, message])  Fails if  actual  is not an instance of  RangeError .  assert.isRangeError(new RangeError( this is a range error ));  // Passes\nassert.isRangeError(new Error( this is not a range error ));   // Fails", 
            "title": "isRangeError()"
        }, 
        {
            "location": "/#messages_33", 
            "text": "assert.isRangeError.message =  Expected ${actual} to be an RangeError ;\nrefute.isRangeError.message =  Expected ${actual} not to be an RangeError ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#isreferenceerror", 
            "text": "assert.isReferenceError(actual[, message])  Fails if  actual  is not an instance of  ReferenceError .  assert.isReferenceError(new ReferenceError( this is a range error ));  // Passes\nassert.isReferenceError(new Error( this is not a range error ));   // Fails", 
            "title": "isReferenceError()"
        }, 
        {
            "location": "/#messages_34", 
            "text": "assert.isReferenceError.message =  Expected ${actual} to be a ReferenceError ;\nrefute.isReferenceError.message =  Expected ${actual} not to be a ReferenceError ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#isregexp", 
            "text": "assert.isRegExp(actual[, message])  Fails if  actual  is not an instance of  RegExp .  assert.isRegExp(new RegExp( apple pie ));  // Passes\nassert.isRegExp(/apple pie/);              // Passes\nassert.isRegExp( apple pie );              // Fails", 
            "title": "isRegExp()"
        }, 
        {
            "location": "/#messages_35", 
            "text": "assert.isRegExp.message =  Expected ${actual} to be an RegExp ;\nrefute.isRegExp.message =  Expected ${actual} not to be an RegExp ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#isset", 
            "text": "assert.isSet(actual[, message])  Fails if  actual  is not an instance of  Set .  assert.isSet(new Set());  // Passes\nassert.isSet([]);         // Fails", 
            "title": "isSet()"
        }, 
        {
            "location": "/#messages_36", 
            "text": "assert.isSet.message =  Expected ${actual} to be a Set ;\nrefute.isSet.message =  Expected ${actual} not to be a Set ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#issymbol", 
            "text": "assert.isSymbol(actual[, message])  Fails if  actual  is not a value of type  Symbol .  assert.isSymbol(Symbol( apple pie ));  // Passes\nassert.isSymbol( apple pie );          // Fails", 
            "title": "isSymbol()"
        }, 
        {
            "location": "/#messages_37", 
            "text": "assert.isSymbol.message =  Expected ${actual} to be a Symbol ;\nrefute.isSymbol.message =  Expected ${actual} not to be a Symbol ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#issyntaxerror", 
            "text": "assert.isSyntaxError(actual[, message])  Fails if  actual  is not an instance of  SyntaxError .  assert.isSyntaxError(new SyntaxError( this is a syntax error ));  // Passes\nassert.isSyntaxError(new Error( this is not a syntax error ));    // Fails", 
            "title": "isSyntaxError()"
        }, 
        {
            "location": "/#messages_38", 
            "text": "assert.isSyntaxError.message =  Expected ${actual} to be a SyntaxError ;\nrefute.isSyntaxError.message =  Expected ${actual} not to be a SyntaxError ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#istypeerror", 
            "text": "assert.isTypeError(actual[, message])  Fails if  actual  is not an instance of  TypeError .  assert.isTypeError(new TypeError( this is a type error ));  // Passes\nassert.isTypeError(new Error( this is not a type error ));  // Fails", 
            "title": "isTypeError()"
        }, 
        {
            "location": "/#messages_39", 
            "text": "assert.isTypeError.message =  Expected ${actual} to be a TypeError ;\nrefute.isTypeError.message =  Expected ${actual} not to be a TypeError ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#isurierror", 
            "text": "assert.isURIError(actual[, message])  Fails if  actual  is not an instance of  URIError .  assert.isURIError(new URIError( this is a uri error ));  // Passes\nassert.isURIError(new Error( this is not a uri error )); // Fails", 
            "title": "isURIError()"
        }, 
        {
            "location": "/#messages_40", 
            "text": "assert.isURIError.message =  Expected ${actual} to be a URIError ;\nrefute.isURIError.message =  Expected ${actual} not to be a URIError ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#isuint16array", 
            "text": "assert.isUint16Array(actual[, message])  Fails if  actual  is not an instance of  Uint16Array .  assert.isUint16Array(new Uint16Array());  // Passes\nassert.isUint16Array(new Uint32Array());  // Fails\nassert.isUint16Array(new Uint8Array());   // Fails", 
            "title": "isUint16Array()"
        }, 
        {
            "location": "/#messages_41", 
            "text": "assert.isUint16Array.message =  Expected ${actual} to be a Uint16Array ;\nrefute.isUint16Array.message =  Expected ${actual} not to be a Uint16Array ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#isuint32array", 
            "text": "assert.isUint32Array(actual[, message])  Fails if  actual  is not an instance of  Uint32Array .  assert.isUint32Array(new Uint16Array());  // Fails\nassert.isUint32Array(new Uint32Array());  // Passes\nassert.isUint32Array(new Uint8Array());   // Fails", 
            "title": "isUint32Array()"
        }, 
        {
            "location": "/#messages_42", 
            "text": "assert.isUint32Array.message =  Expected ${actual} to be a Uint32Array ;\nrefute.isUint32Array.message =  Expected ${actual} not to be a Uint32Array ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#isuint8array", 
            "text": "assert.isUint8Array(actual[, message])  Fails if  actual  is not an instance of  Uint8Array .  assert.isUint8Array(new Uint16Array());  // Fails\nassert.isUint8Array(new Uint32Array());  // Fails\nassert.isUint8Array(new Uint8Array());   // Passes", 
            "title": "isUint8Array()"
        }, 
        {
            "location": "/#messages_43", 
            "text": "assert.isUint8Array.message =  Expected ${actual} to be a Uint8Array ;\nrefute.isUint8Array.message =  Expected ${actual} not to be a Uint8Array ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#isuint8clampedarray", 
            "text": "assert.isUint8ClampedArray(actual[, message])  Fails if  actual  is not an instance of  Uint8ClampedArray .  assert.isUint8ClampedArray(new Uint8ClampedArray());   // Passes\nassert.isUint8ClampedArray(new Uint8Array());          // Fails", 
            "title": "isUint8ClampedArray()"
        }, 
        {
            "location": "/#messages_44", 
            "text": "assert.isUint8ClampedArray.message =  Expected ${actual} to be a Uint8ClampedArray ;\nrefute.isUint8ClampedArray.message =  Expected ${actual} not to be a Uint8ClampedArray ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#isweakmap", 
            "text": "assert.isWeakMap(actual[, message])  Fails if  actual  is not an instance of  WeakMap .  assert.isWeakMap(new WeakMap());   // Passes\nassert.isWeakMap(new Map());       // Fails", 
            "title": "isWeakMap()"
        }, 
        {
            "location": "/#messages_45", 
            "text": "assert.isWeakMap.message =  Expected ${actual} to be a WeakMap ;\nrefute.isWeakMap.message =  Expected ${actual} not to be a WeakMap ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#isweakset", 
            "text": "assert.isWeakSet(actual[, message])  Fails if  actual  is not an instance of  WeakSet .  assert.isWeakSet(new WeakSet());   // Passes\nassert.isWeakSet(new Set());       // Fails", 
            "title": "isWeakSet()"
        }, 
        {
            "location": "/#messages_46", 
            "text": "assert.isWeakSet.message =  Expected ${actual} to be a WeakSet ;\nrefute.isWeakSet.message =  Expected ${actual} not to be a WeakSet ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#keys", 
            "text": "assert.keys(object, keyArray[, message])  Fails if object\u2019s own properties are not exactly the same as a given list.  assert.keys({ test1: 't1', test2: 't2' }, ['test1']);                 // Fails - 'test2' is unexpected\nassert.keys({ test1: 't1', test2: 't2' }, ['test1','test2','test3']); // Fails - 'test3' is not present\nassert.keys({ test1: 't1', test2: 't2' }, ['test1','test2']);         // Passes", 
            "title": "keys()"
        }, 
        {
            "location": "/#messages_47", 
            "text": "assert.keys.message =  Expected ${actualObject} to have exact keys ${keys} ;\nrefute.keys.message =  Expected not to have exact keys ${keys} ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#exception", 
            "text": "assert.exception(callback[, matcher, message])  Fails if  callback  does not throw an exception. If the optional  matcher  is provided, the assertion fails if the callback either does not throw an exception, or if the exception does not meet the criterias of the given `matcher.  The  matcher  can be of type  object  or  function . If the  matcher  is of type  object , the captured error object and the  matcher  are passed to  match() .  If the  matcher  is of type  function , the captured error object is passed as argument to the  matcher  function, which has to return  true  for a matching error object, otherwise  false .  // Passes\nassert.exception(function () {\n    throw new Error( Ooops! );\n});\n\n// Fails\nassert.exception(function () {});\n\n// Passes\nassert.exception(function () {\n    throw new TypeError( Ooops! );\n},  { name:  TypeError  });\n\n// Fails, wrong exception type\nassert.exception(function () {\n    throw new Error( Aww );\n}, { name:  TypeError  });\n\n// Fails, wrong exception message\nassert.exception(function () {\n    throw new Error( Aww );\n}, { message:  Ooops!  });\n\n// Fails, wrong exception type\nassert.exception(function () {\n    throw new Error( Aww );\n}, function (err) {\n    if (err.name !==  TypeError ) {\n        return false;\n    }\n    return true;\n},  Type of exception is wrong! );  // with message to print, if test fails", 
            "title": "exception()"
        }, 
        {
            "location": "/#messages_48", 
            "text": "assert.exception.typeNoExceptionMessage =  Expected ${expected} but no exception was thrown ;\nassert.exception.message =  Expected exception ;\nassert.exception.typeFailMessage =  Expected ${expected} but threw ${actualExceptionType} (${actualExceptionMessage})\\n${actualExceptionStack} ;\nassert.exception.matchFailMessage =  Expected thrown ${actualExceptionType} (${actualExceptionMessage}) to pass matcher function ;\nrefute.exception.message =  Expected not to throw but threw ${actualExceptionType} (${actualExceptionMessage}) ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#near", 
            "text": "assert.near(actual, expected, delta[, message])  Fails if the difference between  actual  and  expected  is greater than  delta .  assert.near(10.3, 10, 0.5); // Passes\nassert.near(10.5, 10, 0.5); // Passes\nassert.near(10.6, 10, 0.5); // Fails", 
            "title": "near()"
        }, 
        {
            "location": "/#messages_49", 
            "text": "assert.near.message =  Expected ${actual} to be equal to ${expected} +/- ${delta} ;\nrefute.near.message =  Expected ${actual} not to be equal to ${expected} +/- ${delta} ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#hasprototype", 
            "text": "assert.hasPrototype(actual, prototype[, message])  Fails if  prototype  does not exist in the prototype chain of  actual .  assert.hasPrototype(function() {}, Function.prototype); // Passes\nassert.hasPrototype(function() {}, Object.prototype);   // Passes\nassert.hasPrototype({}, Function.prototype);            // Fails", 
            "title": "hasPrototype()"
        }, 
        {
            "location": "/#messages_50", 
            "text": "assert.hasPrototype.message =  Expected ${actual} to have ${expected} on its prototype chain ;\nrefute.hasPrototype.message =  Expected ${actual} not to have ${expected} on its prototype chain ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#contains", 
            "text": "assert.contains(haystack, needle[, message])  Fails if the array like object  haystack  does not contain the  needle  argument.  assert.contains([1, 2, 3], 2);   // Passes\nassert.contains([1, 2, 3], 4);   // Fails\nassert.contains([1, 2, 3],  2 ); // Fails", 
            "title": "contains()"
        }, 
        {
            "location": "/#messages_51", 
            "text": "assert.contains.message =  Expected [${actual}] to contain ${expected} ;\nrefute.contains.message =  Expected [${actual}] not to contain ${expected} ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#tagname", 
            "text": "assert.tagName(element, tagName[, message])  Fails if the  element  either does not specify a  tagName  property, or if its value is not a case-insensitive match with the expected  tagName . Works with any object.  assert.tagName(document.createElement( p ),  p ); // Passes\nassert.tagName(document.createElement( h2 ),  H2 ); // Passes\nassert.tagName(document.createElement( p ),  li );  // Fails", 
            "title": "tagName()"
        }, 
        {
            "location": "/#messages_52", 
            "text": "assert.tagName.noTagNameMessage =  Expected ${actualElement} to have tagName property ;\nassert.tagName.message =  Expected tagName to be ${expected} but was ${actual} ;\nrefute.tagName.noTagNameMessage =  Expected ${actualElement} to have tagName property ;\nrefute.tagName.refuteMessage =  Expected tagName not to be ${actual} ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#classname", 
            "text": "assert.className(element, classNames[, message])  Fails if the  element  either does not specify a  className  property, or if its value is not a space-separated list of all class names in  classNames .  classNames  can be either a space-delimited string or an array of class names. Every class specified by classNames must be found in the object\u2019s  className  property for the assertion to pass, but order does not matter.  var el = document.createElement( p );\nel.className =  feed item blog-post ;\n\nassert.className(el,  item );           // Passes\nassert.className(el,  news );           // Fails\nassert.className(el,  blog-post feed ); // Passes\nassert.className(el,  feed items );     // Fails,  items  is not a match\nassert.className(el, [ item ,  feed ]); // Passes", 
            "title": "className()"
        }, 
        {
            "location": "/#messages_53", 
            "text": "assert.className.noClassNameMessage =  Expected object to have className property ;\nassert.className.message =  Expected object's className to include ${expected} but was ${actual} ;\nrefute.className.noClassNameMessage =  Expected object to have className property ;\nrefute.className.message =  Expected object's className not to include ${expected} ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#json", 
            "text": "assert.json(actual, json[, message])  Fails if  actual  is not valid JSON or the parsed JSON is not equal to  json . Uses the same comparison algorithm as  equals() .  var serialized = JSON.stringify({ is: 42 });\n\nassert.json(serialized, { is: 42 }); // Passes\nassert.json(serialized, { or: 42 }); // Fails\nassert.json(serialized, { is: 7 });  // Fails\nassert.json( no-json , {});          // Fails", 
            "title": "json()"
        }, 
        {
            "location": "/#messages_54", 
            "text": "assert.json.message =  Expected ${actual} to equal ${expected} ;\nassert.json.jsonParseExceptionMessage =  Expected ${actual} to be valid JSON ;\nrefute.json.message =  Expected ${actual} not to equal ${expected} ;\nrefute.json.jsonParseExceptionMessage =  Expected ${actual} to be valid JSON ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#matchjson", 
            "text": "assert.matchJson(actual, json[, message])  Fails if  actual  is not valid JSON or the parsed JSON does not match  json . Uses the same matcher algorithm as  match() .  var serialized = JSON.stringify({ is: 42, and: 3 });\n\nassert.matchJson(serialized, { is: 42 }); // Passes\nassert.matchJson(serialized, { and: 3 }); // Passes\nassert.matchJson(serialized, { or: 42 }); // Fails\nassert.matchJson(serialized, { is: 7 });  // Fails\nassert.matchJson( no-json , {});          // Fails", 
            "title": "matchJson()"
        }, 
        {
            "location": "/#messages_55", 
            "text": "assert.json.message =  Expected ${actual} to match ${expected} ;\nassert.json.jsonParseExceptionMessage =  Expected ${actual} to be valid JSON ;\nrefute.json.message =  Expected ${actual} not to match ${expected} ;\nrefute.json.jsonParseExceptionMessage =  Expected ${actual} to be valid JSON ;", 
            "title": "Messages"
        }, 
        {
            "location": "/#custom-assertions", 
            "text": "Custom, domain-specific assertions helps improve clarity and reveal intent in tests. They also facilitate much better feedback when they fail. You can add custom assertions that behave exactly like the built-in ones (i.e. with counting, message formatting, expectations and\nmore) by using the  referee.add  method.", 
            "title": "Custom assertions"
        }, 
        {
            "location": "/#overriding-assertion-messages", 
            "text": "The default assertion messages can be overridden. The messages to\noverwrite are listed with each assertion. You can use the same keys for\nstring interpolation (e.g.  ${actual} ,  ${expected} ). equals:  var assert = require('referee').assert;\nassert.equals.message =  I wanted ${actual} == ${expected}! \n\ntry {\n    assert.equals(3, 4);\n} catch (e) {\n    console.log(e.message);\n}\n\n// Prints:\n//  I wanted 3 == 4!", 
            "title": "Overriding assertion messages"
        }, 
        {
            "location": "/#events", 
            "text": "referee  is an event-emitter. Listen to events with  on :  referee.on( failure , function (err) {\n    console.log(err.message);\n});", 
            "title": "Events"
        }, 
        {
            "location": "/#pass-event", 
            "text": "Signature:  pass , function () {}  Assertion passed. The callback is invoked with the assertion name, e.g. \"equals\" , as its only argument. Note that this event is also emitted\nwhen refutations pass.", 
            "title": "pass event"
        }, 
        {
            "location": "/#failure-event", 
            "text": "Signature:       failure , function (error) {}  Assertion failed. The callback is invoked with an  AssertionError  object.", 
            "title": "failure event"
        }, 
        {
            "location": "/#sinonjs-integration", 
            "text": "You can extend  referee  with assertions that integrates with  Sinon.JS  See  referee-sinon", 
            "title": "Sinon.JS integration"
        }, 
        {
            "location": "/#expectations", 
            "text": "All of referee's assertions and refutations are also exposed as \"expectations\". Expectations is just a slightly different front-end to the same functionality, often preferred by the BDD inclined.  Expectations mirror assertions under different names. Refutations can be expressed using  expect(obj).not  and then calling either of the expectations on the resulting object.  var expect = require('referee').expect;\n\nexpect({ id: 42 }).toBeObject(); // Passes\nexpect( Somewhere in here ).toMatch( in ); // Passes\nexpect(42).not.toEqual(43); // Passes", 
            "title": "Expectations"
        }, 
        {
            "location": "/#expecttobe", 
            "text": "expect(actual).toBe(expected)  See  same()", 
            "title": "expect.toBe()"
        }, 
        {
            "location": "/#expecttoequal", 
            "text": "expect(actual).toEqual(expected)  See  equals()", 
            "title": "expect.toEqual()"
        }, 
        {
            "location": "/#expecttobegreaterthan", 
            "text": "expect(actual).toBeGreaterThan(expected)  See  greater()", 
            "title": "expect.toBeGreaterThan()"
        }, 
        {
            "location": "/#expecttobelessthan", 
            "text": "expect(actual).toBeLessThan(expected)  See  less()", 
            "title": "expect.toBeLessThan()"
        }, 
        {
            "location": "/#expecttobedefined", 
            "text": "expect(actual).toBeDefined(expected)  See  defined()", 
            "title": "expect.toBeDefined()"
        }, 
        {
            "location": "/#expecttobenull", 
            "text": "expect(actual).toBeNull(expected)  See  isNull()", 
            "title": "expect.toBeNull()"
        }, 
        {
            "location": "/#expecttomatch", 
            "text": "expect(actual).toMatch(expected)  See  match()", 
            "title": "expect.toMatch()"
        }, 
        {
            "location": "/#expecttobeobject", 
            "text": "expect(actual).toBeObject(expected)  See  isObject()", 
            "title": "`expect.toBeObject()``"
        }, 
        {
            "location": "/#expecttobefunction", 
            "text": "expect(actual).toBeFunction(expected)  See  isFunction()", 
            "title": "expect.toBeFunction()"
        }, 
        {
            "location": "/#expecttobetrue", 
            "text": "expect(actual).toBeTrue()  See  isTrue()", 
            "title": "expect.toBeTrue()"
        }, 
        {
            "location": "/#expecttobefalse", 
            "text": "expect(actual).toBeFalse()  See  isFalse()", 
            "title": "expect.toBeFalse()"
        }, 
        {
            "location": "/#expecttobestring", 
            "text": "expect(actual).toBeString()  See  isString()", 
            "title": "expect.toBeString()"
        }, 
        {
            "location": "/#expecttobeboolean", 
            "text": "expect(actual).toBeBoolean()  See  isBoolean()", 
            "title": "expect.toBeBoolean()"
        }, 
        {
            "location": "/#expecttobenumber", 
            "text": "expect(actual).toBeNumber()  See  isNumber()", 
            "title": "expect.toBeNumber()"
        }, 
        {
            "location": "/#expecttobenan", 
            "text": "expect(actual).toBeNaN()  See  isNaN()", 
            "title": "expect.toBeNaN()"
        }, 
        {
            "location": "/#expecttobearray", 
            "text": "expect(actual).toBeArray()  See  isArray()", 
            "title": "expect.toBeArray()"
        }, 
        {
            "location": "/#expecttobearraylike", 
            "text": "expect(actual).toBeArrayLike()  See  isArrayLike()", 
            "title": "expect.toBeArrayLike()"
        }, 
        {
            "location": "/#expecttohavekeys", 
            "text": "expect(object).toHaveKeys(keyArray)  See  keys()", 
            "title": "expect.toHaveKeys()"
        }, 
        {
            "location": "/#expecttothrow", 
            "text": "expect(actual).toThrow(expected)  See  exception()", 
            "title": "expect.toThrow()"
        }, 
        {
            "location": "/#expecttobenear", 
            "text": "expect(actual).toBeNear(expected, delta)  See  near()", 
            "title": "expect.toBeNear()"
        }, 
        {
            "location": "/#expecttohaveprototype", 
            "text": "expect(actual).toHavePrototype(prototype)  See  hasPrototype()", 
            "title": "expect.toHavePrototype()"
        }, 
        {
            "location": "/#expecttocontain", 
            "text": "expect(haystack).toContain(needle)  See  contains()", 
            "title": "expect.toContain()"
        }, 
        {
            "location": "/#expecttohavetagname", 
            "text": "expect(actual).toHaveTagName(expected)  See  tagName()", 
            "title": "expect.toHaveTagName()"
        }, 
        {
            "location": "/#expecttohaveclassname", 
            "text": "expect(actual).toHaveClassName(expected)  See  className()", 
            "title": "expect.toHaveClassName()"
        }, 
        {
            "location": "/#expecttoequaljson", 
            "text": "expect(actual).toEqualJson(expected)  See  json()", 
            "title": "expect.toEqualJson()"
        }, 
        {
            "location": "/#expecttomatchjson", 
            "text": "expect(actual).toMatchJson(expected)  See  matchJson()", 
            "title": "expect.toMatchJson()"
        }, 
        {
            "location": "/#expecttohavebeencalled", 
            "text": "expect(spy).toHaveBeenCalled()  See  called()", 
            "title": "expect.toHaveBeenCalled()"
        }, 
        {
            "location": "/#expecttohavebeencalledonce", 
            "text": "expect(spy).toHaveBeenCalledOnce(expected)  See  calledOnce()", 
            "title": "expect.toHaveBeenCalledOnce()"
        }, 
        {
            "location": "/#expecttohavebeencalledtwice", 
            "text": "expect(spy).toHaveBeenCalledTwice(expected)  See  calledTwice()", 
            "title": "expect.toHaveBeenCalledTwice()"
        }, 
        {
            "location": "/#expecttohavebeencalledthrice", 
            "text": "expect(spy).toHaveBeenCalledThrice(expected)  See  calledThrice()", 
            "title": "expect.toHaveBeenCalledThrice()"
        }, 
        {
            "location": "/#expecttohavebeencalledwith", 
            "text": "expect(spy).toHaveBeenCalledWith(arg1, arg2, ...)  See  calledWith()", 
            "title": "expect.toHaveBeenCalledWith()"
        }, 
        {
            "location": "/#expecttohavebeencalledoncewith", 
            "text": "expect(spy).toHaveBeenCalledOnceWith(arg1, arg2, ...)  See  calledOnceWith()", 
            "title": "expect.toHaveBeenCalledOnceWith()"
        }, 
        {
            "location": "/#methods", 
            "text": "", 
            "title": "Methods"
        }, 
        {
            "location": "/#refereefail", 
            "text": "referee.fail(message)  When an assertion fails, it calls  referee.fail()  with the failure message as the only argument. The built-in  fail  function both throws an  AssertionError()  and emits it to the  failure  event. The error can be caught and handled by the test runner. If this behavior is not suitable for your testing framework of choice, you can override  referee.fail()  to make it do the right thing.  Example: To use `referee with JsTestDriver, you can simply configure it as follows:  referee.fail = function (message) {\n    fail(message);\n};  Where the global  fail  function is the one provided by JsTestDriver.  It is possible to make the default  assert.fail  method only emit an event and not throw an error. This may be suitable in asynchronous test runners, where you might not be able to catch exceptions. To silence exceptions, see the  throwOnFailure  property.", 
            "title": "referee.fail()"
        }, 
        {
            "location": "/#refereeformat", 
            "text": "referee.format(object)  Values inserted into assertion messages using the  ${n}  switches are formatted using  referee.format() . By default this method simply coerces the object to a string.  A more expressive option is to use  buster-format , which is a generic function for formatting objects nicely as ASCII. For nice ASCII formatting of objects (including DOM elements) do:  referee.format = buster.format.ascii;", 
            "title": "referee.format()"
        }, 
        {
            "location": "/#refereeadd", 
            "text": "referee.add(name, options)  Add a custom assertion. Using this \u2018macro\u2019 to add project specific assertions has a few advantages:   Assertions will be counted  Failure messages will have interpolated arguments formatted by  referee.format()  A single function generates both an assertion and a refutation  If using expectations, an expectation can easily be generated as well  When  failOnNoAssertions  is set to  true , the assertion will behave correctly (may be important for asynchronous tests)  The assertion will fail if too few arguments are passed   Here\u2019s an example of adding a \u201cfoo\u201d assertion, that only passes when its only argument is the string \u201cfoo\u201d:  var assert = referee.assert;\nvar refute = referee.refute;\nvar expect = referee.expect;\n\nreferee.add( isFoo , {\n    assert: function (actual) {\n        return actual ==  foo ;\n    },\n    assertMessage:  Expected ${0} to be foo! ,\n    refuteMessage:  Expected not to be foo! ,\n    expectation:  toBeFoo \n});\n\n// Now you can do:\n// Passes\nassert.isFoo( foo );\n\n// Fails:  [assert.isFoo] Expected { id: 42 } to be foo! \nassert.isFoo({ id: 42 });\n\n// Fails:  [refute.isFoo] Expected not to be foo! \nrefute.isFoo( foo );\n\n// Passes\nexpect( foo ).toBeFoo();\n\n// To support custom messages, do this:\nreferee.add( isFoo , {\n    assert: function (actual) {\n        return actual ==  foo ;\n    },\n    assertMessage:  ${1}Expected ${0} to be foo! ,\n    refuteMessage:  ${1}Expected not to be foo! ,\n    expectation:  toBeFoo ,\n    values: function (thing, message) {\n        return [thing, message ? message +     :  ];\n    }\n});\n\n// Fails:  [assert.isFoo] Ouch: Expected { id: 42 } to be foo! \nassert.isFoo({ id: 42 },  Ouch );", 
            "title": "referee.add()"
        }, 
        {
            "location": "/#error-message-value-interpolation", 
            "text": "Arguments are available in assertion failure messages using the  \"${n}\"  switches, where  n  is a number. You can also use named variables by setting properties on  this  in the assertion/refutation function:  referee.add( isString , {\n    assert: function (actual) {\n        this.actualType = typeof actual;\n        return this.actualType ==  string ;\n    },\n    assertMessage:  Expected ${0} (${actualType}) to be string ,\n    refuteMessage:  Expected not to be string ,\n    expectation:  toBeString \n});", 
            "title": "Error message value interpolation"
        }, 
        {
            "location": "/#arguments", 
            "text": "`name`: \n     The name of the new assertion/refutation \n     options \n     \n         \n             `assert`: \n             \nThe verification function. Should return `true` when the assertion passes. The generated refutation will pass when the function returns `false`.\n\nIn some cases the refutation may not be the exact opposite of the assertion. If that is the case you should provide `options.refute` for the custom refutation.\n\nThe number of formal parameters the function accepts determines the number of required arguments to the function. If the assertion is called with less arguments than expected, referee will fail it before your custom function is even called.\n\nAll arguments are available for interpolation into the resulting error message. The first argument will be available as `\"${0}\"`, the second as `\"${1}\"` and so on. If you want to embed other values than exact arguments into the string, you can set properties on this in the custom assertion, and refer to them as `\"${name}\"` in the message.\n             \n             `refute`: \n             Custom refutation function. Used over `!assert()` if provided. \n             `assertMessage`: \n             The error message to use when the assertion fails. The message may refer to arguments through switches like `\"${0}\"`` and so on (see above, under the assert argument). The message is exposed on the generated assertion as the property `assert.[name].message`. \n             `refuteMessage`: \n             Like `assertMessage`, but for refutations. Exposed as `refute.[name].message`. \n             `values:` \n             A function that maps values to be interpolated into the failure messages. This can be used when you need something more/else than the actual `arguments` in order. \n             expectation: \n             The name of the assertion as an expectation, e.g. \u201ctoBeSomething\u201d. Optional.", 
            "title": "Arguments"
        }, 
        {
            "location": "/#properties", 
            "text": "", 
            "title": "Properties"
        }, 
        {
            "location": "/#refereecount", 
            "text": "Number  increasing from 0.  referee.count  is incremented anytime an assertion is called. The assertion counter can be reset to any number at your convenience.", 
            "title": "referee.count"
        }, 
        {
            "location": "/#refereethrowonfailure", 
            "text": "Boolean .  When using the default  referee.fail()  implementation, this property can be set to  false  to make assertion failures not throw exceptions (i.e. only emit events). This may be suitable in asynchronous test runners, where you might not be able to catch exceptions.", 
            "title": "`referee.throwOnFailure"
        }, 
        {
            "location": "/#supporting-objects", 
            "text": "", 
            "title": "Supporting objects"
        }, 
        {
            "location": "/#class-assertionerror", 
            "text": "An exception (specifically, an  Error  object) whose  name  property is  \"AssertionError\" .", 
            "title": "class AssertionError()"
        }
    ]
}